"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pmtiles";
exports.ids = ["vendor-chunks/pmtiles"];
exports.modules = {

/***/ "(ssr)/./node_modules/pmtiles/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/pmtiles/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compression: () => (/* binding */ Compression),\n/* harmony export */   EtagMismatch: () => (/* binding */ EtagMismatch),\n/* harmony export */   FetchSource: () => (/* binding */ FetchSource),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   PMTiles: () => (/* binding */ PMTiles),\n/* harmony export */   Protocol: () => (/* binding */ Protocol),\n/* harmony export */   ResolvedValueCache: () => (/* binding */ ResolvedValueCache),\n/* harmony export */   SharedPromiseCache: () => (/* binding */ SharedPromiseCache),\n/* harmony export */   TileType: () => (/* binding */ TileType),\n/* harmony export */   bytesToHeader: () => (/* binding */ bytesToHeader),\n/* harmony export */   findTile: () => (/* binding */ findTile),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   leafletRasterLayer: () => (/* binding */ leafletRasterLayer),\n/* harmony export */   readVarint: () => (/* binding */ readVarint),\n/* harmony export */   tileIdToZxy: () => (/* binding */ tileIdToZxy),\n/* harmony export */   tileTypeExt: () => (/* binding */ tileTypeExt),\n/* harmony export */   zxyToTileId: () => (/* binding */ zxyToTileId)\n/* harmony export */ });\nvar __pow = Math.pow;\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// node_modules/fflate/esm/browser.js\nvar u8 = Uint8Array;\nvar u16 = Uint16Array;\nvar i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2);\nvar fl = _a.b;\nvar revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0);\nvar fd = _b.b;\nvar revfd = _b.r;\nvar rev = new u16(32768);\nfor (i = 0; i < 32768; ++i) {\n  x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar x;\nvar i;\nvar hMap = function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (i = 0; i < 144; ++i)\n  flt[i] = 8;\nvar i;\nfor (i = 144; i < 256; ++i)\n  flt[i] = 9;\nvar i;\nfor (i = 256; i < 280; ++i)\n  flt[i] = 7;\nvar i;\nfor (i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar i;\nvar fdt = new u8(32);\nfor (i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar i;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max = function(a) {\n  var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n      m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = 0;\n  if (e == null || e > v.length)\n    e = v.length;\n  var n = new u8(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf || st.i != 2;\n  var noSt = st.i;\n  if (!buf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if (l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + l);\n        buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * 8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max(clt), clbmsk = (1 << clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & 15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            var c = 0, n = 0;\n            if (s == 16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n          }\n        }\n        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        lbt = max(lt);\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n        err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n    }\n    if (noBuf)\n      cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for (; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if (sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        var add = sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + 131072);\n        var end = bt + add;\n        if (bt < dt) {\n          var shift2 = dl - dt, dend = Math.min(dt, end);\n          if (shift2 + bt < 0)\n            err(3);\n          for (; bt < dend; ++bt)\n            buf[bt] = dict[shift2 + bt];\n        }\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n        bt = end;\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n      final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar gzs = function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n    st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar gzl = function(d) {\n  var l = d.length;\n  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\nvar zls = function(d, dict) {\n  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)\n    err(6, \"invalid zlib data\");\n  if ((d[1] >> 5 & 1) == +!dict)\n    err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n  return (d[1] >> 3 & 4) + 2;\n};\nfunction inflateSync(data, opts) {\n  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction gunzipSync(data, opts) {\n  var st = gzs(data);\n  if (st + 8 > data.length)\n    err(6, \"invalid gzip data\");\n  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\nfunction unzlibSync(data, opts) {\n  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction decompressSync(data, opts) {\n  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);\n}\nvar td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\n\n// v2.ts\nvar shift = (n, shift2) => {\n  return n * __pow(2, shift2);\n};\nvar unshift = (n, shift2) => {\n  return Math.floor(n / __pow(2, shift2));\n};\nvar getUint24 = (view, pos) => {\n  return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);\n};\nvar getUint48 = (view, pos) => {\n  return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);\n};\nvar compare = (tz, tx, ty, view, i) => {\n  if (tz !== view.getUint8(i))\n    return tz - view.getUint8(i);\n  const x = getUint24(view, i + 1);\n  if (tx !== x)\n    return tx - x;\n  const y = getUint24(view, i + 4);\n  if (ty !== y)\n    return ty - y;\n  return 0;\n};\nvar queryLeafdir = (view, z, x, y) => {\n  const offsetLen = queryView(view, z | 128, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: true\n    };\n  }\n  return null;\n};\nvar queryTile = (view, z, x, y) => {\n  const offsetLen = queryView(view, z, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: false\n    };\n  }\n  return null;\n};\nvar queryView = (view, z, x, y) => {\n  let m = 0;\n  let n = view.byteLength / 17 - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = compare(z, x, y, view, k * 17);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];\n    }\n  }\n  return null;\n};\nvar entrySort = (a, b) => {\n  if (a.isDir && !b.isDir) {\n    return 1;\n  }\n  if (!a.isDir && b.isDir) {\n    return -1;\n  }\n  if (a.z !== b.z) {\n    return a.z - b.z;\n  }\n  if (a.x !== b.x) {\n    return a.x - b.x;\n  }\n  return a.y - b.y;\n};\nvar parseEntry = (dataview, i) => {\n  const zRaw = dataview.getUint8(i * 17);\n  const z = zRaw & 127;\n  return {\n    z,\n    x: getUint24(dataview, i * 17 + 1),\n    y: getUint24(dataview, i * 17 + 4),\n    offset: getUint48(dataview, i * 17 + 7),\n    length: dataview.getUint32(i * 17 + 13, true),\n    isDir: zRaw >> 7 === 1\n  };\n};\nvar sortDir = (a) => {\n  const entries = [];\n  const view = new DataView(a);\n  for (let i = 0; i < view.byteLength / 17; i++) {\n    entries.push(parseEntry(view, i));\n  }\n  return createDirectory(entries);\n};\nvar createDirectory = (entries) => {\n  entries.sort(entrySort);\n  const buffer = new ArrayBuffer(17 * entries.length);\n  const arr = new Uint8Array(buffer);\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    let z = entry.z;\n    if (entry.isDir)\n      z = z | 128;\n    arr[i * 17] = z;\n    arr[i * 17 + 1] = entry.x & 255;\n    arr[i * 17 + 2] = entry.x >> 8 & 255;\n    arr[i * 17 + 3] = entry.x >> 16 & 255;\n    arr[i * 17 + 4] = entry.y & 255;\n    arr[i * 17 + 5] = entry.y >> 8 & 255;\n    arr[i * 17 + 6] = entry.y >> 16 & 255;\n    arr[i * 17 + 7] = entry.offset & 255;\n    arr[i * 17 + 8] = unshift(entry.offset, 8) & 255;\n    arr[i * 17 + 9] = unshift(entry.offset, 16) & 255;\n    arr[i * 17 + 10] = unshift(entry.offset, 24) & 255;\n    arr[i * 17 + 11] = unshift(entry.offset, 32) & 255;\n    arr[i * 17 + 12] = unshift(entry.offset, 48) & 255;\n    arr[i * 17 + 13] = entry.length & 255;\n    arr[i * 17 + 14] = entry.length >> 8 & 255;\n    arr[i * 17 + 15] = entry.length >> 16 & 255;\n    arr[i * 17 + 16] = entry.length >> 24 & 255;\n  }\n  return buffer;\n};\nvar deriveLeaf = (view, tile) => {\n  if (view.byteLength < 17)\n    return null;\n  const numEntries = view.byteLength / 17;\n  const entry = parseEntry(view, numEntries - 1);\n  if (entry.isDir) {\n    const leafLevel = entry.z;\n    const levelDiff = tile.z - leafLevel;\n    const leafX = Math.trunc(tile.x / (1 << levelDiff));\n    const leafY = Math.trunc(tile.y / (1 << levelDiff));\n    return { z: leafLevel, x: leafX, y: leafY };\n  }\n  return null;\n};\nfunction getHeader(source) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 512e3);\n    const dataview = new DataView(resp.data);\n    const jsonSize = dataview.getUint32(4, true);\n    const rootEntries = dataview.getUint16(8, true);\n    const dec = new TextDecoder(\"utf-8\");\n    const jsonMetadata = JSON.parse(\n      dec.decode(new DataView(resp.data, 10, jsonSize))\n    );\n    let tileCompression = 0 /* Unknown */;\n    if (jsonMetadata.compression === \"gzip\") {\n      tileCompression = 2 /* Gzip */;\n    }\n    let minzoom = 0;\n    if (\"minzoom\" in jsonMetadata) {\n      minzoom = +jsonMetadata.minzoom;\n    }\n    let maxzoom = 0;\n    if (\"maxzoom\" in jsonMetadata) {\n      maxzoom = +jsonMetadata.maxzoom;\n    }\n    let centerLon = 0;\n    let centerLat = 0;\n    let centerZoom = 0;\n    let minLon = -180;\n    let minLat = -85;\n    let maxLon = 180;\n    let maxLat = 85;\n    if (jsonMetadata.bounds) {\n      const split = jsonMetadata.bounds.split(\",\");\n      minLon = +split[0];\n      minLat = +split[1];\n      maxLon = +split[2];\n      maxLat = +split[3];\n    }\n    if (jsonMetadata.center) {\n      const split = jsonMetadata.center.split(\",\");\n      centerLon = +split[0];\n      centerLat = +split[1];\n      centerZoom = +split[2];\n    }\n    const header = {\n      specVersion: dataview.getUint16(2, true),\n      rootDirectoryOffset: 10 + jsonSize,\n      rootDirectoryLength: rootEntries * 17,\n      jsonMetadataOffset: 10,\n      jsonMetadataLength: jsonSize,\n      leafDirectoryOffset: 0,\n      leafDirectoryLength: void 0,\n      tileDataOffset: 0,\n      tileDataLength: void 0,\n      numAddressedTiles: 0,\n      numTileEntries: 0,\n      numTileContents: 0,\n      clustered: false,\n      internalCompression: 1 /* None */,\n      tileCompression,\n      tileType: 1 /* Mvt */,\n      minZoom: minzoom,\n      maxZoom: maxzoom,\n      minLon,\n      minLat,\n      maxLon,\n      maxLat,\n      centerZoom,\n      centerLon,\n      centerLat,\n      etag: resp.etag\n    };\n    return header;\n  });\n}\nfunction getZxy(header, source, cache, z, x, y, signal) {\n  return __async(this, null, function* () {\n    let rootDir = yield cache.getArrayBuffer(\n      source,\n      header.rootDirectoryOffset,\n      header.rootDirectoryLength,\n      header\n    );\n    if (header.specVersion === 1) {\n      rootDir = sortDir(rootDir);\n    }\n    const entry = queryTile(new DataView(rootDir), z, x, y);\n    if (entry) {\n      const resp = yield source.getBytes(entry.offset, entry.length, signal);\n      let tileData = resp.data;\n      const view = new DataView(tileData);\n      if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n        tileData = decompressSync(new Uint8Array(tileData));\n      }\n      return {\n        data: tileData\n      };\n    }\n    const leafcoords = deriveLeaf(new DataView(rootDir), { z, x, y });\n    if (leafcoords) {\n      const leafdirEntry = queryLeafdir(\n        new DataView(rootDir),\n        leafcoords.z,\n        leafcoords.x,\n        leafcoords.y\n      );\n      if (leafdirEntry) {\n        let leafDir = yield cache.getArrayBuffer(\n          source,\n          leafdirEntry.offset,\n          leafdirEntry.length,\n          header\n        );\n        if (header.specVersion === 1) {\n          leafDir = sortDir(leafDir);\n        }\n        const tileEntry = queryTile(new DataView(leafDir), z, x, y);\n        if (tileEntry) {\n          const resp = yield source.getBytes(\n            tileEntry.offset,\n            tileEntry.length,\n            signal\n          );\n          let tileData = resp.data;\n          const view = new DataView(tileData);\n          if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n            tileData = decompressSync(new Uint8Array(tileData));\n          }\n          return {\n            data: tileData\n          };\n        }\n      }\n    }\n    return void 0;\n  });\n}\nvar v2_default = {\n  getHeader,\n  getZxy\n};\n\n// adapters.ts\nvar leafletRasterLayer = (source, options) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord, done) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === 1 /* Mvt */) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source.getZxy(coord.z, coord.x, coord.y, signal).then((arr) => {\n        if (arr) {\n          const blob = new Blob([arr.data], { type: mimeType });\n          const imageUrl = window.URL.createObjectURL(blob);\n          el.src = imageUrl;\n          el.cancel = void 0;\n          done(void 0, el);\n        }\n      }).catch((e) => {\n        if (e.name !== \"AbortError\") {\n          throw e;\n        }\n      });\n      return el;\n    },\n    _removeTile: function(key) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      if (tile.el.cancel)\n        tile.el.cancel();\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    }\n  });\n  return new cls(options);\n};\nvar v3compat = (v4) => (requestParameters, arg2) => {\n  if (arg2 instanceof AbortController) {\n    return v4(requestParameters, arg2);\n  }\n  const abortController = new AbortController();\n  v4(requestParameters, abortController).then(\n    (result) => {\n      return arg2(\n        void 0,\n        result.data,\n        result.cacheControl || \"\",\n        result.expires || \"\"\n      );\n    },\n    (err2) => {\n      return arg2(err2);\n    }\n  ).catch((e) => {\n    return arg2(e);\n  });\n  return { cancel: () => abortController.abort() };\n};\nvar Protocol = class {\n  /**\n   * Initialize the MapLibre PMTiles protocol.\n   *\n   * * metadata: also load the metadata section of the PMTiles. required for some \"inspect\" functionality\n   * and to automatically populate the map attribution. Requires an extra HTTP request.\n   */\n  constructor(options) {\n    /** @hidden */\n    this.tilev4 = (params, abortController) => __async(this, null, function* () {\n      if (params.type === \"json\") {\n        const pmtilesUrl2 = params.url.substr(10);\n        let instance2 = this.tiles.get(pmtilesUrl2);\n        if (!instance2) {\n          instance2 = new PMTiles(pmtilesUrl2);\n          this.tiles.set(pmtilesUrl2, instance2);\n        }\n        if (this.metadata) {\n          return {\n            data: yield instance2.getTileJson(params.url)\n          };\n        }\n        const h = yield instance2.getHeader();\n        return {\n          data: {\n            tiles: [`${params.url}/{z}/{x}/{y}`],\n            minzoom: h.minZoom,\n            maxzoom: h.maxZoom,\n            bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat]\n          }\n        };\n      }\n      const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n      const result = params.url.match(re);\n      if (!result) {\n        throw new Error(\"Invalid PMTiles protocol URL\");\n      }\n      const pmtilesUrl = result[1];\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n      const z = result[2];\n      const x = result[3];\n      const y = result[4];\n      const header = yield instance.getHeader();\n      const resp = yield instance == null ? void 0 : instance.getZxy(+z, +x, +y, abortController.signal);\n      if (resp) {\n        return {\n          data: new Uint8Array(resp.data),\n          cacheControl: resp.cacheControl,\n          expires: resp.expires\n        };\n      }\n      if (header.tileType === 1 /* Mvt */) {\n        return { data: new Uint8Array() };\n      }\n      return { data: null };\n    });\n    this.tile = v3compat(this.tilev4);\n    this.tiles = /* @__PURE__ */ new Map();\n    this.metadata = (options == null ? void 0 : options.metadata) || false;\n  }\n  /**\n   * Add a {@link PMTiles} instance to the global protocol instance.\n   *\n   * For remote fetch sources, references in MapLibre styles like pmtiles://http://...\n   * will resolve to the same instance if the URLs match.\n   */\n  add(p) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n  /**\n   * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.\n   */\n  get(url) {\n    return this.tiles.get(url);\n  }\n};\n\n// index.ts\nfunction toNum(low, high) {\n  return (high >>> 0) * 4294967296 + (low >>> 0);\n}\nfunction readVarintRemainder(l, p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 112) >> 4;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 3;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 10;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 17;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 24;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 1) << 31;\n  if (b < 128)\n    return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\nfunction readVarint(p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 127;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 7;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 14;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 21;\n  if (b < 128)\n    return val;\n  b = buf[p.pos];\n  val |= (b & 15) << 28;\n  return readVarintRemainder(val, p);\n}\nfunction rotate(n, xy, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\nfunction idOnLevel(z, pos) {\n  const n = __pow(2, z);\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & t / 2;\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\nvar tzValues = [\n  0,\n  1,\n  5,\n  21,\n  85,\n  341,\n  1365,\n  5461,\n  21845,\n  87381,\n  349525,\n  1398101,\n  5592405,\n  22369621,\n  89478485,\n  357913941,\n  1431655765,\n  5726623061,\n  22906492245,\n  91625968981,\n  366503875925,\n  1466015503701,\n  5864062014805,\n  23456248059221,\n  93824992236885,\n  375299968947541,\n  1501199875790165\n];\nfunction zxyToTileId(z, x, y) {\n  if (z > 26) {\n    throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > __pow(2, z) - 1 || y > __pow(2, z) - 1) {\n    throw Error(\"tile x/y outside zoom level bounds\");\n  }\n  const acc = tzValues[z];\n  const n = __pow(2, z);\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * (3 * rx ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\nfunction tileIdToZxy(i) {\n  let acc = 0;\n  const z = 0;\n  for (let z2 = 0; z2 < 27; z2++) {\n    const numTiles = (1 << z2) * (1 << z2);\n    if (acc + numTiles > i) {\n      return idOnLevel(z2, i - acc);\n    }\n    acc += numTiles;\n  }\n  throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\nvar Compression = /* @__PURE__ */ ((Compression2) => {\n  Compression2[Compression2[\"Unknown\"] = 0] = \"Unknown\";\n  Compression2[Compression2[\"None\"] = 1] = \"None\";\n  Compression2[Compression2[\"Gzip\"] = 2] = \"Gzip\";\n  Compression2[Compression2[\"Brotli\"] = 3] = \"Brotli\";\n  Compression2[Compression2[\"Zstd\"] = 4] = \"Zstd\";\n  return Compression2;\n})(Compression || {});\nfunction defaultDecompress(buf, compression) {\n  return __async(this, null, function* () {\n    if (compression === 1 /* None */ || compression === 0 /* Unknown */) {\n      return buf;\n    }\n    if (compression === 2 /* Gzip */) {\n      if (typeof globalThis.DecompressionStream === \"undefined\") {\n        return decompressSync(new Uint8Array(buf));\n      }\n      const stream = new Response(buf).body;\n      if (!stream) {\n        throw Error(\"Failed to read response stream\");\n      }\n      const result = stream.pipeThrough(\n        // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n        new globalThis.DecompressionStream(\"gzip\")\n      );\n      return new Response(result).arrayBuffer();\n    }\n    throw Error(\"Compression method not supported\");\n  });\n}\nvar TileType = /* @__PURE__ */ ((TileType2) => {\n  TileType2[TileType2[\"Unknown\"] = 0] = \"Unknown\";\n  TileType2[TileType2[\"Mvt\"] = 1] = \"Mvt\";\n  TileType2[TileType2[\"Png\"] = 2] = \"Png\";\n  TileType2[TileType2[\"Jpeg\"] = 3] = \"Jpeg\";\n  TileType2[TileType2[\"Webp\"] = 4] = \"Webp\";\n  TileType2[TileType2[\"Avif\"] = 5] = \"Avif\";\n  return TileType2;\n})(TileType || {});\nfunction tileTypeExt(t) {\n  if (t === 1 /* Mvt */)\n    return \".mvt\";\n  if (t === 2 /* Png */)\n    return \".png\";\n  if (t === 3 /* Jpeg */)\n    return \".jpg\";\n  if (t === 4 /* Webp */)\n    return \".webp\";\n  if (t === 5 /* Avif */)\n    return \".avif\";\n  return \"\";\n}\nvar HEADER_SIZE_BYTES = 127;\nfunction findTile(entries, tileId) {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\nvar FileSource = class {\n  constructor(file) {\n    this.file = file;\n  }\n  getKey() {\n    return this.file.name;\n  }\n  getBytes(offset, length) {\n    return __async(this, null, function* () {\n      const blob = this.file.slice(offset, offset + length);\n      const a = yield blob.arrayBuffer();\n      return { data: a };\n    });\n  }\n};\nvar FetchSource = class {\n  constructor(url, customHeaders = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n    let userAgent = \"\";\n    if (\"navigator\" in globalThis) {\n      userAgent = globalThis.navigator.userAgent || \"\";\n    }\n    const isWindows = userAgent.indexOf(\"Windows\") > -1;\n    const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);\n    this.chromeWindowsNoCache = false;\n    if (isWindows && isChromiumBased) {\n      this.chromeWindowsNoCache = true;\n    }\n  }\n  getKey() {\n    return this.url;\n  }\n  /**\n   * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   */\n  setHeaders(customHeaders) {\n    this.customHeaders = customHeaders;\n  }\n  getBytes(offset, length, passedSignal, etag) {\n    return __async(this, null, function* () {\n      let controller;\n      let signal;\n      if (passedSignal) {\n        signal = passedSignal;\n      } else {\n        controller = new AbortController();\n        signal = controller.signal;\n      }\n      const requestHeaders = new Headers(this.customHeaders);\n      requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n      let cache;\n      if (this.mustReload) {\n        cache = \"reload\";\n      } else if (this.chromeWindowsNoCache) {\n        cache = \"no-store\";\n      }\n      let resp = yield fetch(this.url, {\n        signal,\n        cache,\n        headers: requestHeaders\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      });\n      if (offset === 0 && resp.status === 416) {\n        const contentRange = resp.headers.get(\"Content-Range\");\n        if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n          throw Error(\"Missing content-length on 416 response\");\n        }\n        const actualLength = +contentRange.substr(8);\n        resp = yield fetch(this.url, {\n          signal,\n          cache: \"reload\",\n          headers: { range: `bytes=0-${actualLength - 1}` }\n          //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n        });\n      }\n      let newEtag = resp.headers.get(\"Etag\");\n      if (newEtag == null ? void 0 : newEtag.startsWith(\"W/\")) {\n        newEtag = null;\n      }\n      if (resp.status === 416 || etag && newEtag && newEtag !== etag) {\n        this.mustReload = true;\n        throw new EtagMismatch(\n          `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n        );\n      }\n      if (resp.status >= 300) {\n        throw Error(`Bad response code: ${resp.status}`);\n      }\n      const contentLength = resp.headers.get(\"Content-Length\");\n      if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n        if (controller)\n          controller.abort();\n        throw Error(\n          \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n        );\n      }\n      const a = yield resp.arrayBuffer();\n      return {\n        data: a,\n        etag: newEtag || void 0,\n        cacheControl: resp.headers.get(\"Cache-Control\") || void 0,\n        expires: resp.headers.get(\"Expires\") || void 0\n      };\n    });\n  }\n};\nfunction getUint64(v, offset) {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * __pow(2, 32) + wl;\n}\nfunction bytesToHeader(bytes, etag) {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n  return {\n    specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 1e7,\n    minLat: v.getInt32(106, true) / 1e7,\n    maxLon: v.getInt32(110, true) / 1e7,\n    maxLat: v.getInt32(114, true) / 1e7,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 1e7,\n    centerLat: v.getInt32(123, true) / 1e7,\n    etag\n  };\n}\nfunction deserializeIndex(buffer) {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n  const entries = [];\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n  return entries;\n}\nfunction detectVersion(a) {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.warn(\n      \"PMTiles spec version 2 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.warn(\n      \"PMTiles spec version 1 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\nvar EtagMismatch = class extends Error {\n};\nfunction getHeaderAndRoot(source, decompress) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 16384);\n    const v = new DataView(resp.data);\n    if (v.getUint16(0, true) !== 19792) {\n      throw new Error(\"Wrong magic number for PMTiles archive\");\n    }\n    if (detectVersion(resp.data) < 3) {\n      return [yield v2_default.getHeader(source)];\n    }\n    const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n    const header = bytesToHeader(headerData, resp.etag);\n    const rootDirData = resp.data.slice(\n      header.rootDirectoryOffset,\n      header.rootDirectoryOffset + header.rootDirectoryLength\n    );\n    const dirKey = `${source.getKey()}|${header.etag || \"\"}|${header.rootDirectoryOffset}|${header.rootDirectoryLength}`;\n    const rootDir = deserializeIndex(\n      yield decompress(rootDirData, header.internalCompression)\n    );\n    return [header, [dirKey, rootDir.length, rootDir]];\n  });\n}\nfunction getDirectory(source, decompress, offset, length, header) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(offset, length, void 0, header.etag);\n    const data = yield decompress(resp.data, header.internalCompression);\n    const directory = deserializeIndex(data);\n    if (directory.length === 0) {\n      throw new Error(\"Empty directory is invalid\");\n    }\n    return directory;\n  });\n}\nvar ResolvedValueCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const res = yield getHeaderAndRoot(source, this.decompress);\n      if (res[1]) {\n        this.cache.set(res[1][0], {\n          lastUsed: this.counter++,\n          data: res[1][2]\n        });\n      }\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: res[0]\n      });\n      this.prune();\n      return res[0];\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const directory = yield getDirectory(\n        source,\n        this.decompress,\n        offset,\n        length,\n        header\n      );\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: directory\n      });\n      this.prune();\n      return directory;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const resp = yield source.getBytes(offset, length, void 0, header.etag);\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: resp.data\n      });\n      this.prune();\n      return resp.data;\n    });\n  }\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      this.cache.delete(source.getKey());\n    });\n  }\n};\nvar SharedPromiseCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.invalidations = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getHeaderAndRoot(source, this.decompress).then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2])\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getDirectory(source, this.decompress, offset, length, header).then((directory) => {\n          resolve(directory);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        source.getBytes(offset, length, void 0, header.etag).then((resp) => {\n          resolve(resp.data);\n          if (this.cache.has(cacheKey)) {\n          }\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      const key = source.getKey();\n      if (this.invalidations.get(key)) {\n        return yield this.invalidations.get(key);\n      }\n      this.cache.delete(source.getKey());\n      const p = new Promise((resolve, reject) => {\n        this.getHeader(source).then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.invalidations.set(key, p);\n    });\n  }\n};\nvar PMTiles = class {\n  constructor(source, cache, decompress) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  getHeader() {\n    return __async(this, null, function* () {\n      return yield this.cache.getHeader(this.source);\n    });\n  }\n  /** @hidden */\n  getZxyAttempt(z, x, y, signal) {\n    return __async(this, null, function* () {\n      const tileId = zxyToTileId(z, x, y);\n      const header = yield this.cache.getHeader(this.source);\n      if (header.specVersion < 3) {\n        return v2_default.getZxy(header, this.source, this.cache, z, x, y, signal);\n      }\n      if (z < header.minZoom || z > header.maxZoom) {\n        return void 0;\n      }\n      let dO = header.rootDirectoryOffset;\n      let dL = header.rootDirectoryLength;\n      for (let depth = 0; depth <= 3; depth++) {\n        const directory = yield this.cache.getDirectory(\n          this.source,\n          dO,\n          dL,\n          header\n        );\n        const entry = findTile(directory, tileId);\n        if (entry) {\n          if (entry.runLength > 0) {\n            const resp = yield this.source.getBytes(\n              header.tileDataOffset + entry.offset,\n              entry.length,\n              signal,\n              header.etag\n            );\n            return {\n              data: yield this.decompress(resp.data, header.tileCompression),\n              cacheControl: resp.cacheControl,\n              expires: resp.expires\n            };\n          }\n          dO = header.leafDirectoryOffset + entry.offset;\n          dL = entry.length;\n        } else {\n          return void 0;\n        }\n      }\n      throw Error(\"Maximum directory depth exceeded\");\n    });\n  }\n  /**\n   * Primary method to get a single tile's bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  getZxy(z, x, y, signal) {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getZxyAttempt(z, x, y, signal);\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getZxyAttempt(z, x, y, signal);\n        }\n        throw e;\n      }\n    });\n  }\n  /** @hidden */\n  getMetadataAttempt() {\n    return __async(this, null, function* () {\n      const header = yield this.cache.getHeader(this.source);\n      const resp = yield this.source.getBytes(\n        header.jsonMetadataOffset,\n        header.jsonMetadataLength,\n        void 0,\n        header.etag\n      );\n      const decompressed = yield this.decompress(\n        resp.data,\n        header.internalCompression\n      );\n      const dec = new TextDecoder(\"utf-8\");\n      return JSON.parse(dec.decode(decompressed));\n    });\n  }\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  getMetadata() {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getMetadataAttempt();\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getMetadataAttempt();\n        }\n        throw e;\n      }\n    });\n  }\n  /**\n   * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.\n   *\n   * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.\n   * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,\n   * the baseTilesUrl should be `https://example.com/tileset`.\n   */\n  getTileJson(baseTilesUrl) {\n    return __async(this, null, function* () {\n      const header = yield this.getHeader();\n      const metadata = yield this.getMetadata();\n      const ext = tileTypeExt(header.tileType);\n      return {\n        tilejson: \"3.0.0\",\n        scheme: \"xyz\",\n        tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],\n        // biome-ignore lint: TileJSON spec\n        vector_layers: metadata.vector_layers,\n        attribution: metadata.attribution,\n        description: metadata.description,\n        name: metadata.name,\n        version: metadata.version,\n        bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],\n        center: [header.centerLon, header.centerLat, header.centerZoom],\n        minzoom: header.minZoom,\n        maxzoom: header.maxZoom\n      };\n    });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG10aWxlcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJO0FBQ3BGLHFFQUFxRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBbUJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3ZlcmxhbmRpbmctbWFwcy8uL25vZGVfbW9kdWxlcy9wbXRpbGVzL2Rpc3QvaW5kZXguanM/ZmI3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19wb3cgPSBNYXRoLnBvdztcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanNcbnZhciB1OCA9IFVpbnQ4QXJyYXk7XG52YXIgdTE2ID0gVWludDE2QXJyYXk7XG52YXIgaTMyID0gSW50MzJBcnJheTtcbnZhciBmbGViID0gbmV3IHU4KFtcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMixcbiAgMixcbiAgMixcbiAgMixcbiAgMyxcbiAgMyxcbiAgMyxcbiAgMyxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgMCxcbiAgLyogdW51c2VkICovXG4gIDAsXG4gIDAsXG4gIC8qIGltcG9zc2libGUgKi9cbiAgMFxuXSk7XG52YXIgZmRlYiA9IG5ldyB1OChbXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDEsXG4gIDEsXG4gIDIsXG4gIDIsXG4gIDMsXG4gIDMsXG4gIDQsXG4gIDQsXG4gIDUsXG4gIDUsXG4gIDYsXG4gIDYsXG4gIDcsXG4gIDcsXG4gIDgsXG4gIDgsXG4gIDksXG4gIDksXG4gIDEwLFxuICAxMCxcbiAgMTEsXG4gIDExLFxuICAxMixcbiAgMTIsXG4gIDEzLFxuICAxMyxcbiAgLyogdW51c2VkICovXG4gIDAsXG4gIDBcbl0pO1xudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbnZhciBmcmViID0gZnVuY3Rpb24oZWIsIHN0YXJ0KSB7XG4gIHZhciBiID0gbmV3IHUxNigzMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzE7ICsraSkge1xuICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgfVxuICB2YXIgciA9IG5ldyBpMzIoYlszMF0pO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gYltpXTsgaiA8IGJbaSArIDFdOyArK2opIHtcbiAgICAgIHJbal0gPSBqIC0gYltpXSA8PCA1IHwgaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgYiwgciB9O1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMik7XG52YXIgZmwgPSBfYS5iO1xudmFyIHJldmZsID0gX2EucjtcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKTtcbnZhciBmZCA9IF9iLmI7XG52YXIgcmV2ZmQgPSBfYi5yO1xudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yIChpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgeCA9IChpICYgNDM2OTApID4+IDEgfCAoaSAmIDIxODQ1KSA8PCAxO1xuICB4ID0gKHggJiA1MjQyOCkgPj4gMiB8ICh4ICYgMTMxMDcpIDw8IDI7XG4gIHggPSAoeCAmIDYxNjgwKSA+PiA0IHwgKHggJiAzODU1KSA8PCA0O1xuICByZXZbaV0gPSAoKHggJiA2NTI4MCkgPj4gOCB8ICh4ICYgMjU1KSA8PCA4KSA+PiAxO1xufVxudmFyIHg7XG52YXIgaTtcbnZhciBoTWFwID0gZnVuY3Rpb24oY2QsIG1iLCByKSB7XG4gIHZhciBzID0gY2QubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gbmV3IHUxNihtYik7XG4gIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgaWYgKGNkW2ldKVxuICAgICAgKytsW2NkW2ldIC0gMV07XG4gIH1cbiAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gIGZvciAoaSA9IDE7IGkgPCBtYjsgKytpKSB7XG4gICAgbGVbaV0gPSBsZVtpIC0gMV0gKyBsW2kgLSAxXSA8PCAxO1xuICB9XG4gIHZhciBjbztcbiAgaWYgKHIpIHtcbiAgICBjbyA9IG5ldyB1MTYoMSA8PCBtYik7XG4gICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgIHZhciBzdiA9IGkgPDwgNCB8IGNkW2ldO1xuICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgcl8xO1xuICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgxIDw8IHJfMSkgLSAxOyB2IDw9IG07ICsrdikge1xuICAgICAgICAgIGNvW3Jldlt2XSA+PiBydmJdID0gc3Y7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY28gPSBuZXcgdTE2KHMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICBjb1tpXSA9IHJldltsZVtjZFtpXSAtIDFdKytdID4+IDE1IC0gY2RbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbztcbn07XG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gIGZsdFtpXSA9IDg7XG52YXIgaTtcbmZvciAoaSA9IDE0NDsgaSA8IDI1NjsgKytpKVxuICBmbHRbaV0gPSA5O1xudmFyIGk7XG5mb3IgKGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgZmx0W2ldID0gNztcbnZhciBpO1xuZm9yIChpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gIGZsdFtpXSA9IDg7XG52YXIgaTtcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yIChpID0gMDsgaSA8IDMyOyArK2kpXG4gIGZkdFtpXSA9IDU7XG52YXIgaTtcbnZhciBmbHJtID0gLyogQF9fUFVSRV9fICovIGhNYXAoZmx0LCA5LCAxKTtcbnZhciBmZHJtID0gLyogQF9fUFVSRV9fICovIGhNYXAoZmR0LCA1LCAxKTtcbnZhciBtYXggPSBmdW5jdGlvbihhKSB7XG4gIHZhciBtID0gYVswXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFbaV0gPiBtKVxuICAgICAgbSA9IGFbaV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xudmFyIGJpdHMgPSBmdW5jdGlvbihkLCBwLCBtKSB7XG4gIHZhciBvID0gcCAvIDggfCAwO1xuICByZXR1cm4gKGRbb10gfCBkW28gKyAxXSA8PCA4KSA+PiAocCAmIDcpICYgbTtcbn07XG52YXIgYml0czE2ID0gZnVuY3Rpb24oZCwgcCkge1xuICB2YXIgbyA9IHAgLyA4IHwgMDtcbiAgcmV0dXJuIChkW29dIHwgZFtvICsgMV0gPDwgOCB8IGRbbyArIDJdIDw8IDE2KSA+PiAocCAmIDcpO1xufTtcbnZhciBzaGZ0ID0gZnVuY3Rpb24ocCkge1xuICByZXR1cm4gKHAgKyA3KSAvIDggfCAwO1xufTtcbnZhciBzbGMgPSBmdW5jdGlvbih2LCBzLCBlKSB7XG4gIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgcyA9IDA7XG4gIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgIGUgPSB2Lmxlbmd0aDtcbiAgdmFyIG4gPSBuZXcgdTgoZSAtIHMpO1xuICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgcmV0dXJuIG47XG59O1xudmFyIGVjID0gW1xuICBcInVuZXhwZWN0ZWQgRU9GXCIsXG4gIFwiaW52YWxpZCBibG9jayB0eXBlXCIsXG4gIFwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbFwiLFxuICBcImludmFsaWQgZGlzdGFuY2VcIixcbiAgXCJzdHJlYW0gZmluaXNoZWRcIixcbiAgXCJubyBzdHJlYW0gaGFuZGxlclwiLFxuICAsXG4gIFwibm8gY2FsbGJhY2tcIixcbiAgXCJpbnZhbGlkIFVURi04IGRhdGFcIixcbiAgXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiLFxuICBcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFxuICBcImZpbGVuYW1lIHRvbyBsb25nXCIsXG4gIFwic3RyZWFtIGZpbmlzaGluZ1wiLFxuICBcImludmFsaWQgemlwIGRhdGFcIlxuICAvLyBkZXRlcm1pbmVkIGJ5IHVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXG5dO1xudmFyIGVyciA9IGZ1bmN0aW9uKGluZCwgbXNnLCBudCkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gIGUuY29kZSA9IGluZDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGUsIGVycik7XG4gIGlmICghbnQpXG4gICAgdGhyb3cgZTtcbiAgcmV0dXJuIGU7XG59O1xudmFyIGluZmx0ID0gZnVuY3Rpb24oZGF0LCBzdCwgYnVmLCBkaWN0KSB7XG4gIHZhciBzbCA9IGRhdC5sZW5ndGgsIGRsID0gZGljdCA/IGRpY3QubGVuZ3RoIDogMDtcbiAgaWYgKCFzbCB8fCBzdC5mICYmICFzdC5sKVxuICAgIHJldHVybiBidWYgfHwgbmV3IHU4KDApO1xuICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0LmkgIT0gMjtcbiAgdmFyIG5vU3QgPSBzdC5pO1xuICBpZiAoIWJ1ZilcbiAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgdmFyIGNidWYgPSBmdW5jdGlvbihsMikge1xuICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKGwyID4gYmwpIHtcbiAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbDIpKTtcbiAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICBidWYgPSBuYnVmO1xuICAgIH1cbiAgfTtcbiAgdmFyIGZpbmFsID0gc3QuZiB8fCAwLCBwb3MgPSBzdC5wIHx8IDAsIGJ0ID0gc3QuYiB8fCAwLCBsbSA9IHN0LmwsIGRtID0gc3QuZCwgbGJ0ID0gc3QubSwgZGJ0ID0gc3QubjtcbiAgdmFyIHRidHMgPSBzbCAqIDg7XG4gIGRvIHtcbiAgICBpZiAoIWxtKSB7XG4gICAgICBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICBwb3MgKz0gMztcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB2YXIgcyA9IHNoZnQocG9zKSArIDQsIGwgPSBkYXRbcyAtIDRdIHwgZGF0W3MgLSAzXSA8PCA4LCB0ID0gcyArIGw7XG4gICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICBzdC5iID0gYnQgKz0gbCwgc3QucCA9IHBvcyA9IHQgKiA4LCBzdC5mID0gZmluYWw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgIGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1O1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7XG4gICAgICAgIHZhciBoTGl0ID0gYml0cyhkYXQsIHBvcywgMzEpICsgMjU3LCBoY0xlbiA9IGJpdHMoZGF0LCBwb3MgKyAxMCwgMTUpICsgNDtcbiAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgY2x0W2NsaW1baV1dID0gYml0cyhkYXQsIHBvcyArIGkgKiAzLCA3KTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7ICkge1xuICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgIHBvcyArPSByICYgMTU7XG4gICAgICAgICAgdmFyIHMgPSByID4+IDQ7XG4gICAgICAgICAgaWYgKHMgPCAxNikge1xuICAgICAgICAgICAgbGR0W2krK10gPSBzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgMyksIHBvcyArPSAyLCBjID0gbGR0W2kgLSAxXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTcpXG4gICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7XG4gICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICBsZHRbaSsrXSA9IGM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgIGxidCA9IG1heChsdCk7XG4gICAgICAgIGRidCA9IG1heChkdCk7XG4gICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGVycigxKTtcbiAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgIGlmIChub1N0KVxuICAgICAgICAgIGVycigwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub0J1ZilcbiAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgZm9yICg7IDsgbHBvcyA9IHBvcykge1xuICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+PiA0O1xuICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgIGlmIChub1N0KVxuICAgICAgICAgIGVycigwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWMpXG4gICAgICAgIGVycigyKTtcbiAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgIGJ1ZltidCsrXSA9IHN5bTtcbiAgICAgIGVsc2UgaWYgKHN5bSA9PSAyNTYpIHtcbiAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgYWRkID0gYml0cyhkYXQsIHBvcywgKDEgPDwgYikgLSAxKSArIGZsW2ldO1xuICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkID0gZG1bYml0czE2KGRhdCwgcG9zKSAmIGRtc10sIGRzeW0gPSBkID4+IDQ7XG4gICAgICAgIGlmICghZClcbiAgICAgICAgICBlcnIoMyk7XG4gICAgICAgIHBvcyArPSBkICYgMTU7XG4gICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgZHQgKz0gYml0czE2KGRhdCwgcG9zKSAmICgxIDw8IGIpIC0gMSwgcG9zICs9IGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgaWYgKGJ0IDwgZHQpIHtcbiAgICAgICAgICB2YXIgc2hpZnQyID0gZGwgLSBkdCwgZGVuZCA9IE1hdGgubWluKGR0LCBlbmQpO1xuICAgICAgICAgIGlmIChzaGlmdDIgKyBidCA8IDApXG4gICAgICAgICAgICBlcnIoMyk7XG4gICAgICAgICAgZm9yICg7IGJ0IDwgZGVuZDsgKytidClcbiAgICAgICAgICAgIGJ1ZltidF0gPSBkaWN0W3NoaWZ0MiArIGJ0XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7IGJ0ICs9IDQpIHtcbiAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgIGJ1ZltidCArIDFdID0gYnVmW2J0ICsgMSAtIGR0XTtcbiAgICAgICAgICBidWZbYnQgKyAyXSA9IGJ1ZltidCArIDIgLSBkdF07XG4gICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICB9XG4gICAgICAgIGJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQsIHN0LmYgPSBmaW5hbDtcbiAgICBpZiAobG0pXG4gICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgfSB3aGlsZSAoIWZpbmFsKTtcbiAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xudmFyIGV0ID0gLyogQF9fUFVSRV9fICovIG5ldyB1OCgwKTtcbnZhciBnenMgPSBmdW5jdGlvbihkKSB7XG4gIGlmIChkWzBdICE9IDMxIHx8IGRbMV0gIT0gMTM5IHx8IGRbMl0gIT0gOClcbiAgICBlcnIoNiwgXCJpbnZhbGlkIGd6aXAgZGF0YVwiKTtcbiAgdmFyIGZsZyA9IGRbM107XG4gIHZhciBzdCA9IDEwO1xuICBpZiAoZmxnICYgNClcbiAgICBzdCArPSAoZFsxMF0gfCBkWzExXSA8PCA4KSArIDI7XG4gIGZvciAodmFyIHpzID0gKGZsZyA+PiAzICYgMSkgKyAoZmxnID4+IDQgJiAxKTsgenMgPiAwOyB6cyAtPSAhZFtzdCsrXSlcbiAgICA7XG4gIHJldHVybiBzdCArIChmbGcgJiAyKTtcbn07XG52YXIgZ3psID0gZnVuY3Rpb24oZCkge1xuICB2YXIgbCA9IGQubGVuZ3RoO1xuICByZXR1cm4gKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2IHwgZFtsIC0gMV0gPDwgMjQpID4+PiAwO1xufTtcbnZhciB6bHMgPSBmdW5jdGlvbihkLCBkaWN0KSB7XG4gIGlmICgoZFswXSAmIDE1KSAhPSA4IHx8IGRbMF0gPj4gNCA+IDcgfHwgKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpXG4gICAgZXJyKDYsIFwiaW52YWxpZCB6bGliIGRhdGFcIik7XG4gIGlmICgoZFsxXSA+PiA1ICYgMSkgPT0gKyFkaWN0KVxuICAgIGVycig2LCBcImludmFsaWQgemxpYiBkYXRhOiBcIiArIChkWzFdICYgMzIgPyBcIm5lZWRcIiA6IFwidW5leHBlY3RlZFwiKSArIFwiIGRpY3Rpb25hcnlcIik7XG4gIHJldHVybiAoZFsxXSA+PiAzICYgNCkgKyAyO1xufTtcbmZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG9wdHMpIHtcbiAgcmV0dXJuIGluZmx0KGRhdGEsIHsgaTogMiB9LCBvcHRzICYmIG9wdHMub3V0LCBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSk7XG59XG5mdW5jdGlvbiBndW56aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgdmFyIHN0ID0gZ3pzKGRhdGEpO1xuICBpZiAoc3QgKyA4ID4gZGF0YS5sZW5ndGgpXG4gICAgZXJyKDYsIFwiaW52YWxpZCBnemlwIGRhdGFcIik7XG4gIHJldHVybiBpbmZsdChkYXRhLnN1YmFycmF5KHN0LCAtOCksIHsgaTogMiB9LCBvcHRzICYmIG9wdHMub3V0IHx8IG5ldyB1OChnemwoZGF0YSkpLCBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSk7XG59XG5mdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoemxzKGRhdGEsIG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5KSwgLTQpLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3B0cykge1xuICByZXR1cm4gZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDggPyBndW56aXBTeW5jKGRhdGEsIG9wdHMpIDogKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCBkYXRhWzBdID4+IDQgPiA3IHx8IChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3B0cykgOiB1bnpsaWJTeW5jKGRhdGEsIG9wdHMpO1xufVxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9IFwidW5kZWZpbmVkXCIgJiYgLyogQF9fUFVSRV9fICovIG5ldyBUZXh0RGVjb2RlcigpO1xudmFyIHRkcyA9IDA7XG50cnkge1xuICB0ZC5kZWNvZGUoZXQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICB0ZHMgPSAxO1xufSBjYXRjaCAoZSkge1xufVxuXG4vLyB2Mi50c1xudmFyIHNoaWZ0ID0gKG4sIHNoaWZ0MikgPT4ge1xuICByZXR1cm4gbiAqIF9fcG93KDIsIHNoaWZ0Mik7XG59O1xudmFyIHVuc2hpZnQgPSAobiwgc2hpZnQyKSA9PiB7XG4gIHJldHVybiBNYXRoLmZsb29yKG4gLyBfX3BvdygyLCBzaGlmdDIpKTtcbn07XG52YXIgZ2V0VWludDI0ID0gKHZpZXcsIHBvcykgPT4ge1xuICByZXR1cm4gc2hpZnQodmlldy5nZXRVaW50MTYocG9zICsgMSwgdHJ1ZSksIDgpICsgdmlldy5nZXRVaW50OChwb3MpO1xufTtcbnZhciBnZXRVaW50NDggPSAodmlldywgcG9zKSA9PiB7XG4gIHJldHVybiBzaGlmdCh2aWV3LmdldFVpbnQzMihwb3MgKyAyLCB0cnVlKSwgMTYpICsgdmlldy5nZXRVaW50MTYocG9zLCB0cnVlKTtcbn07XG52YXIgY29tcGFyZSA9ICh0eiwgdHgsIHR5LCB2aWV3LCBpKSA9PiB7XG4gIGlmICh0eiAhPT0gdmlldy5nZXRVaW50OChpKSlcbiAgICByZXR1cm4gdHogLSB2aWV3LmdldFVpbnQ4KGkpO1xuICBjb25zdCB4ID0gZ2V0VWludDI0KHZpZXcsIGkgKyAxKTtcbiAgaWYgKHR4ICE9PSB4KVxuICAgIHJldHVybiB0eCAtIHg7XG4gIGNvbnN0IHkgPSBnZXRVaW50MjQodmlldywgaSArIDQpO1xuICBpZiAodHkgIT09IHkpXG4gICAgcmV0dXJuIHR5IC0geTtcbiAgcmV0dXJuIDA7XG59O1xudmFyIHF1ZXJ5TGVhZmRpciA9ICh2aWV3LCB6LCB4LCB5KSA9PiB7XG4gIGNvbnN0IG9mZnNldExlbiA9IHF1ZXJ5Vmlldyh2aWV3LCB6IHwgMTI4LCB4LCB5KTtcbiAgaWYgKG9mZnNldExlbikge1xuICAgIHJldHVybiB7XG4gICAgICB6LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBvZmZzZXQ6IG9mZnNldExlblswXSxcbiAgICAgIGxlbmd0aDogb2Zmc2V0TGVuWzFdLFxuICAgICAgaXNEaXI6IHRydWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBxdWVyeVRpbGUgPSAodmlldywgeiwgeCwgeSkgPT4ge1xuICBjb25zdCBvZmZzZXRMZW4gPSBxdWVyeVZpZXcodmlldywgeiwgeCwgeSk7XG4gIGlmIChvZmZzZXRMZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgb2Zmc2V0OiBvZmZzZXRMZW5bMF0sXG4gICAgICBsZW5ndGg6IG9mZnNldExlblsxXSxcbiAgICAgIGlzRGlyOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHF1ZXJ5VmlldyA9ICh2aWV3LCB6LCB4LCB5KSA9PiB7XG4gIGxldCBtID0gMDtcbiAgbGV0IG4gPSB2aWV3LmJ5dGVMZW5ndGggLyAxNyAtIDE7XG4gIHdoaWxlIChtIDw9IG4pIHtcbiAgICBjb25zdCBrID0gbiArIG0gPj4gMTtcbiAgICBjb25zdCBjbXAgPSBjb21wYXJlKHosIHgsIHksIHZpZXcsIGsgKiAxNyk7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIG0gPSBrICsgMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgIG4gPSBrIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtnZXRVaW50NDgodmlldywgayAqIDE3ICsgNyksIHZpZXcuZ2V0VWludDMyKGsgKiAxNyArIDEzLCB0cnVlKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBlbnRyeVNvcnQgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5pc0RpciAmJiAhYi5pc0Rpcikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmICghYS5pc0RpciAmJiBiLmlzRGlyKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChhLnogIT09IGIueikge1xuICAgIHJldHVybiBhLnogLSBiLno7XG4gIH1cbiAgaWYgKGEueCAhPT0gYi54KSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbiAgfVxuICByZXR1cm4gYS55IC0gYi55O1xufTtcbnZhciBwYXJzZUVudHJ5ID0gKGRhdGF2aWV3LCBpKSA9PiB7XG4gIGNvbnN0IHpSYXcgPSBkYXRhdmlldy5nZXRVaW50OChpICogMTcpO1xuICBjb25zdCB6ID0gelJhdyAmIDEyNztcbiAgcmV0dXJuIHtcbiAgICB6LFxuICAgIHg6IGdldFVpbnQyNChkYXRhdmlldywgaSAqIDE3ICsgMSksXG4gICAgeTogZ2V0VWludDI0KGRhdGF2aWV3LCBpICogMTcgKyA0KSxcbiAgICBvZmZzZXQ6IGdldFVpbnQ0OChkYXRhdmlldywgaSAqIDE3ICsgNyksXG4gICAgbGVuZ3RoOiBkYXRhdmlldy5nZXRVaW50MzIoaSAqIDE3ICsgMTMsIHRydWUpLFxuICAgIGlzRGlyOiB6UmF3ID4+IDcgPT09IDFcbiAgfTtcbn07XG52YXIgc29ydERpciA9IChhKSA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3LmJ5dGVMZW5ndGggLyAxNzsgaSsrKSB7XG4gICAgZW50cmllcy5wdXNoKHBhcnNlRW50cnkodmlldywgaSkpO1xuICB9XG4gIHJldHVybiBjcmVhdGVEaXJlY3RvcnkoZW50cmllcyk7XG59O1xudmFyIGNyZWF0ZURpcmVjdG9yeSA9IChlbnRyaWVzKSA9PiB7XG4gIGVudHJpZXMuc29ydChlbnRyeVNvcnQpO1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMTcgKiBlbnRyaWVzLmxlbmd0aCk7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICBsZXQgeiA9IGVudHJ5Lno7XG4gICAgaWYgKGVudHJ5LmlzRGlyKVxuICAgICAgeiA9IHogfCAxMjg7XG4gICAgYXJyW2kgKiAxN10gPSB6O1xuICAgIGFycltpICogMTcgKyAxXSA9IGVudHJ5LnggJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDJdID0gZW50cnkueCA+PiA4ICYgMjU1O1xuICAgIGFycltpICogMTcgKyAzXSA9IGVudHJ5LnggPj4gMTYgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDRdID0gZW50cnkueSAmIDI1NTtcbiAgICBhcnJbaSAqIDE3ICsgNV0gPSBlbnRyeS55ID4+IDggJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDZdID0gZW50cnkueSA+PiAxNiAmIDI1NTtcbiAgICBhcnJbaSAqIDE3ICsgN10gPSBlbnRyeS5vZmZzZXQgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDhdID0gdW5zaGlmdChlbnRyeS5vZmZzZXQsIDgpICYgMjU1O1xuICAgIGFycltpICogMTcgKyA5XSA9IHVuc2hpZnQoZW50cnkub2Zmc2V0LCAxNikgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDEwXSA9IHVuc2hpZnQoZW50cnkub2Zmc2V0LCAyNCkgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDExXSA9IHVuc2hpZnQoZW50cnkub2Zmc2V0LCAzMikgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDEyXSA9IHVuc2hpZnQoZW50cnkub2Zmc2V0LCA0OCkgJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDEzXSA9IGVudHJ5Lmxlbmd0aCAmIDI1NTtcbiAgICBhcnJbaSAqIDE3ICsgMTRdID0gZW50cnkubGVuZ3RoID4+IDggJiAyNTU7XG4gICAgYXJyW2kgKiAxNyArIDE1XSA9IGVudHJ5Lmxlbmd0aCA+PiAxNiAmIDI1NTtcbiAgICBhcnJbaSAqIDE3ICsgMTZdID0gZW50cnkubGVuZ3RoID4+IDI0ICYgMjU1O1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xudmFyIGRlcml2ZUxlYWYgPSAodmlldywgdGlsZSkgPT4ge1xuICBpZiAodmlldy5ieXRlTGVuZ3RoIDwgMTcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG51bUVudHJpZXMgPSB2aWV3LmJ5dGVMZW5ndGggLyAxNztcbiAgY29uc3QgZW50cnkgPSBwYXJzZUVudHJ5KHZpZXcsIG51bUVudHJpZXMgLSAxKTtcbiAgaWYgKGVudHJ5LmlzRGlyKSB7XG4gICAgY29uc3QgbGVhZkxldmVsID0gZW50cnkuejtcbiAgICBjb25zdCBsZXZlbERpZmYgPSB0aWxlLnogLSBsZWFmTGV2ZWw7XG4gICAgY29uc3QgbGVhZlggPSBNYXRoLnRydW5jKHRpbGUueCAvICgxIDw8IGxldmVsRGlmZikpO1xuICAgIGNvbnN0IGxlYWZZID0gTWF0aC50cnVuYyh0aWxlLnkgLyAoMSA8PCBsZXZlbERpZmYpKTtcbiAgICByZXR1cm4geyB6OiBsZWFmTGV2ZWwsIHg6IGxlYWZYLCB5OiBsZWFmWSB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmZ1bmN0aW9uIGdldEhlYWRlcihzb3VyY2UpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCByZXNwID0geWllbGQgc291cmNlLmdldEJ5dGVzKDAsIDUxMmUzKTtcbiAgICBjb25zdCBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyhyZXNwLmRhdGEpO1xuICAgIGNvbnN0IGpzb25TaXplID0gZGF0YXZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgIGNvbnN0IHJvb3RFbnRyaWVzID0gZGF0YXZpZXcuZ2V0VWludDE2KDgsIHRydWUpO1xuICAgIGNvbnN0IGRlYyA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIGNvbnN0IGpzb25NZXRhZGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICBkZWMuZGVjb2RlKG5ldyBEYXRhVmlldyhyZXNwLmRhdGEsIDEwLCBqc29uU2l6ZSkpXG4gICAgKTtcbiAgICBsZXQgdGlsZUNvbXByZXNzaW9uID0gMCAvKiBVbmtub3duICovO1xuICAgIGlmIChqc29uTWV0YWRhdGEuY29tcHJlc3Npb24gPT09IFwiZ3ppcFwiKSB7XG4gICAgICB0aWxlQ29tcHJlc3Npb24gPSAyIC8qIEd6aXAgKi87XG4gICAgfVxuICAgIGxldCBtaW56b29tID0gMDtcbiAgICBpZiAoXCJtaW56b29tXCIgaW4ganNvbk1ldGFkYXRhKSB7XG4gICAgICBtaW56b29tID0gK2pzb25NZXRhZGF0YS5taW56b29tO1xuICAgIH1cbiAgICBsZXQgbWF4em9vbSA9IDA7XG4gICAgaWYgKFwibWF4em9vbVwiIGluIGpzb25NZXRhZGF0YSkge1xuICAgICAgbWF4em9vbSA9ICtqc29uTWV0YWRhdGEubWF4em9vbTtcbiAgICB9XG4gICAgbGV0IGNlbnRlckxvbiA9IDA7XG4gICAgbGV0IGNlbnRlckxhdCA9IDA7XG4gICAgbGV0IGNlbnRlclpvb20gPSAwO1xuICAgIGxldCBtaW5Mb24gPSAtMTgwO1xuICAgIGxldCBtaW5MYXQgPSAtODU7XG4gICAgbGV0IG1heExvbiA9IDE4MDtcbiAgICBsZXQgbWF4TGF0ID0gODU7XG4gICAgaWYgKGpzb25NZXRhZGF0YS5ib3VuZHMpIHtcbiAgICAgIGNvbnN0IHNwbGl0ID0ganNvbk1ldGFkYXRhLmJvdW5kcy5zcGxpdChcIixcIik7XG4gICAgICBtaW5Mb24gPSArc3BsaXRbMF07XG4gICAgICBtaW5MYXQgPSArc3BsaXRbMV07XG4gICAgICBtYXhMb24gPSArc3BsaXRbMl07XG4gICAgICBtYXhMYXQgPSArc3BsaXRbM107XG4gICAgfVxuICAgIGlmIChqc29uTWV0YWRhdGEuY2VudGVyKSB7XG4gICAgICBjb25zdCBzcGxpdCA9IGpzb25NZXRhZGF0YS5jZW50ZXIuc3BsaXQoXCIsXCIpO1xuICAgICAgY2VudGVyTG9uID0gK3NwbGl0WzBdO1xuICAgICAgY2VudGVyTGF0ID0gK3NwbGl0WzFdO1xuICAgICAgY2VudGVyWm9vbSA9ICtzcGxpdFsyXTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgc3BlY1ZlcnNpb246IGRhdGF2aWV3LmdldFVpbnQxNigyLCB0cnVlKSxcbiAgICAgIHJvb3REaXJlY3RvcnlPZmZzZXQ6IDEwICsganNvblNpemUsXG4gICAgICByb290RGlyZWN0b3J5TGVuZ3RoOiByb290RW50cmllcyAqIDE3LFxuICAgICAganNvbk1ldGFkYXRhT2Zmc2V0OiAxMCxcbiAgICAgIGpzb25NZXRhZGF0YUxlbmd0aDoganNvblNpemUsXG4gICAgICBsZWFmRGlyZWN0b3J5T2Zmc2V0OiAwLFxuICAgICAgbGVhZkRpcmVjdG9yeUxlbmd0aDogdm9pZCAwLFxuICAgICAgdGlsZURhdGFPZmZzZXQ6IDAsXG4gICAgICB0aWxlRGF0YUxlbmd0aDogdm9pZCAwLFxuICAgICAgbnVtQWRkcmVzc2VkVGlsZXM6IDAsXG4gICAgICBudW1UaWxlRW50cmllczogMCxcbiAgICAgIG51bVRpbGVDb250ZW50czogMCxcbiAgICAgIGNsdXN0ZXJlZDogZmFsc2UsXG4gICAgICBpbnRlcm5hbENvbXByZXNzaW9uOiAxIC8qIE5vbmUgKi8sXG4gICAgICB0aWxlQ29tcHJlc3Npb24sXG4gICAgICB0aWxlVHlwZTogMSAvKiBNdnQgKi8sXG4gICAgICBtaW5ab29tOiBtaW56b29tLFxuICAgICAgbWF4Wm9vbTogbWF4em9vbSxcbiAgICAgIG1pbkxvbixcbiAgICAgIG1pbkxhdCxcbiAgICAgIG1heExvbixcbiAgICAgIG1heExhdCxcbiAgICAgIGNlbnRlclpvb20sXG4gICAgICBjZW50ZXJMb24sXG4gICAgICBjZW50ZXJMYXQsXG4gICAgICBldGFnOiByZXNwLmV0YWdcbiAgICB9O1xuICAgIHJldHVybiBoZWFkZXI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Wnh5KGhlYWRlciwgc291cmNlLCBjYWNoZSwgeiwgeCwgeSwgc2lnbmFsKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IHJvb3REaXIgPSB5aWVsZCBjYWNoZS5nZXRBcnJheUJ1ZmZlcihcbiAgICAgIHNvdXJjZSxcbiAgICAgIGhlYWRlci5yb290RGlyZWN0b3J5T2Zmc2V0LFxuICAgICAgaGVhZGVyLnJvb3REaXJlY3RvcnlMZW5ndGgsXG4gICAgICBoZWFkZXJcbiAgICApO1xuICAgIGlmIChoZWFkZXIuc3BlY1ZlcnNpb24gPT09IDEpIHtcbiAgICAgIHJvb3REaXIgPSBzb3J0RGlyKHJvb3REaXIpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHF1ZXJ5VGlsZShuZXcgRGF0YVZpZXcocm9vdERpciksIHosIHgsIHkpO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIHNvdXJjZS5nZXRCeXRlcyhlbnRyeS5vZmZzZXQsIGVudHJ5Lmxlbmd0aCwgc2lnbmFsKTtcbiAgICAgIGxldCB0aWxlRGF0YSA9IHJlc3AuZGF0YTtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcodGlsZURhdGEpO1xuICAgICAgaWYgKHZpZXcuZ2V0VWludDgoMCkgPT09IDMxICYmIHZpZXcuZ2V0VWludDgoMSkgPT09IDEzOSkge1xuICAgICAgICB0aWxlRGF0YSA9IGRlY29tcHJlc3NTeW5jKG5ldyBVaW50OEFycmF5KHRpbGVEYXRhKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB0aWxlRGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbGVhZmNvb3JkcyA9IGRlcml2ZUxlYWYobmV3IERhdGFWaWV3KHJvb3REaXIpLCB7IHosIHgsIHkgfSk7XG4gICAgaWYgKGxlYWZjb29yZHMpIHtcbiAgICAgIGNvbnN0IGxlYWZkaXJFbnRyeSA9IHF1ZXJ5TGVhZmRpcihcbiAgICAgICAgbmV3IERhdGFWaWV3KHJvb3REaXIpLFxuICAgICAgICBsZWFmY29vcmRzLnosXG4gICAgICAgIGxlYWZjb29yZHMueCxcbiAgICAgICAgbGVhZmNvb3Jkcy55XG4gICAgICApO1xuICAgICAgaWYgKGxlYWZkaXJFbnRyeSkge1xuICAgICAgICBsZXQgbGVhZkRpciA9IHlpZWxkIGNhY2hlLmdldEFycmF5QnVmZmVyKFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBsZWFmZGlyRW50cnkub2Zmc2V0LFxuICAgICAgICAgIGxlYWZkaXJFbnRyeS5sZW5ndGgsXG4gICAgICAgICAgaGVhZGVyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChoZWFkZXIuc3BlY1ZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICBsZWFmRGlyID0gc29ydERpcihsZWFmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWxlRW50cnkgPSBxdWVyeVRpbGUobmV3IERhdGFWaWV3KGxlYWZEaXIpLCB6LCB4LCB5KTtcbiAgICAgICAgaWYgKHRpbGVFbnRyeSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCBzb3VyY2UuZ2V0Qnl0ZXMoXG4gICAgICAgICAgICB0aWxlRW50cnkub2Zmc2V0LFxuICAgICAgICAgICAgdGlsZUVudHJ5Lmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ25hbFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHRpbGVEYXRhID0gcmVzcC5kYXRhO1xuICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcodGlsZURhdGEpO1xuICAgICAgICAgIGlmICh2aWV3LmdldFVpbnQ4KDApID09PSAzMSAmJiB2aWV3LmdldFVpbnQ4KDEpID09PSAxMzkpIHtcbiAgICAgICAgICAgIHRpbGVEYXRhID0gZGVjb21wcmVzc1N5bmMobmV3IFVpbnQ4QXJyYXkodGlsZURhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRpbGVEYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbn1cbnZhciB2Ml9kZWZhdWx0ID0ge1xuICBnZXRIZWFkZXIsXG4gIGdldFp4eVxufTtcblxuLy8gYWRhcHRlcnMudHNcbnZhciBsZWFmbGV0UmFzdGVyTGF5ZXIgPSAoc291cmNlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgbGV0IG1pbWVUeXBlID0gXCJcIjtcbiAgY29uc3QgY2xzID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICBjcmVhdGVUaWxlOiAoY29vcmQsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGVsLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfTtcbiAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgIHNvdXJjZS5nZXRIZWFkZXIoKS50aGVuKChoZWFkZXIpID0+IHtcbiAgICAgICAgICBpZiAoaGVhZGVyLnRpbGVUeXBlID09PSAxIC8qIE12dCAqLykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFcnJvcjogYXJjaGl2ZSBjb250YWlucyBNVlQgdmVjdG9yIHRpbGVzLCBidXQgbGVhZmxldFJhc3RlckxheWVyIGlzIGZvciBkaXNwbGF5aW5nIHJhc3RlciB0aWxlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b21hcHMvUE1UaWxlcy90cmVlL21haW4vanMgZm9yIGRldGFpbHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIudGlsZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIG1pbWVUeXBlID0gXCJpbWFnZS9wbmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci50aWxlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgbWltZVR5cGUgPSBcImltYWdlL2pwZWdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci50aWxlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgbWltZVR5cGUgPSBcImltYWdlL3dlYnBcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci50aWxlVHlwZSA9PT0gNSkge1xuICAgICAgICAgICAgbWltZVR5cGUgPSBcImltYWdlL2F2aWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmdldFp4eShjb29yZC56LCBjb29yZC54LCBjb29yZC55LCBzaWduYWwpLnRoZW4oKGFycikgPT4ge1xuICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFthcnIuZGF0YV0sIHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICBlbC5zcmMgPSBpbWFnZVVybDtcbiAgICAgICAgICBlbC5jYW5jZWwgPSB2b2lkIDA7XG4gICAgICAgICAgZG9uZSh2b2lkIDAsIGVsKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSAhPT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuICAgIF9yZW1vdmVUaWxlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aWxlLmVsLmNhbmNlbClcbiAgICAgICAgdGlsZS5lbC5jYW5jZWwoKTtcbiAgICAgIHRpbGUuZWwud2lkdGggPSAwO1xuICAgICAgdGlsZS5lbC5oZWlnaHQgPSAwO1xuICAgICAgdGlsZS5lbC5kZWxldGVkID0gdHJ1ZTtcbiAgICAgIEwuRG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG4gICAgICBkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcbiAgICAgIHRoaXMuZmlyZShcInRpbGV1bmxvYWRcIiwge1xuICAgICAgICB0aWxlOiB0aWxlLmVsLFxuICAgICAgICBjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IGNscyhvcHRpb25zKTtcbn07XG52YXIgdjNjb21wYXQgPSAodjQpID0+IChyZXF1ZXN0UGFyYW1ldGVycywgYXJnMikgPT4ge1xuICBpZiAoYXJnMiBpbnN0YW5jZW9mIEFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiB2NChyZXF1ZXN0UGFyYW1ldGVycywgYXJnMik7XG4gIH1cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICB2NChyZXF1ZXN0UGFyYW1ldGVycywgYWJvcnRDb250cm9sbGVyKS50aGVuKFxuICAgIChyZXN1bHQpID0+IHtcbiAgICAgIHJldHVybiBhcmcyKFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlc3VsdC5kYXRhLFxuICAgICAgICByZXN1bHQuY2FjaGVDb250cm9sIHx8IFwiXCIsXG4gICAgICAgIHJlc3VsdC5leHBpcmVzIHx8IFwiXCJcbiAgICAgICk7XG4gICAgfSxcbiAgICAoZXJyMikgPT4ge1xuICAgICAgcmV0dXJuIGFyZzIoZXJyMik7XG4gICAgfVxuICApLmNhdGNoKChlKSA9PiB7XG4gICAgcmV0dXJuIGFyZzIoZSk7XG4gIH0pO1xuICByZXR1cm4geyBjYW5jZWw6ICgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpIH07XG59O1xudmFyIFByb3RvY29sID0gY2xhc3Mge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgTWFwTGlicmUgUE1UaWxlcyBwcm90b2NvbC5cbiAgICpcbiAgICogKiBtZXRhZGF0YTogYWxzbyBsb2FkIHRoZSBtZXRhZGF0YSBzZWN0aW9uIG9mIHRoZSBQTVRpbGVzLiByZXF1aXJlZCBmb3Igc29tZSBcImluc3BlY3RcIiBmdW5jdGlvbmFsaXR5XG4gICAqIGFuZCB0byBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlIHRoZSBtYXAgYXR0cmlidXRpb24uIFJlcXVpcmVzIGFuIGV4dHJhIEhUVFAgcmVxdWVzdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHRoaXMudGlsZXY0ID0gKHBhcmFtcywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAocGFyYW1zLnR5cGUgPT09IFwianNvblwiKSB7XG4gICAgICAgIGNvbnN0IHBtdGlsZXNVcmwyID0gcGFyYW1zLnVybC5zdWJzdHIoMTApO1xuICAgICAgICBsZXQgaW5zdGFuY2UyID0gdGhpcy50aWxlcy5nZXQocG10aWxlc1VybDIpO1xuICAgICAgICBpZiAoIWluc3RhbmNlMikge1xuICAgICAgICAgIGluc3RhbmNlMiA9IG5ldyBQTVRpbGVzKHBtdGlsZXNVcmwyKTtcbiAgICAgICAgICB0aGlzLnRpbGVzLnNldChwbXRpbGVzVXJsMiwgaW5zdGFuY2UyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB5aWVsZCBpbnN0YW5jZTIuZ2V0VGlsZUpzb24ocGFyYW1zLnVybClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGggPSB5aWVsZCBpbnN0YW5jZTIuZ2V0SGVhZGVyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGlsZXM6IFtgJHtwYXJhbXMudXJsfS97en0ve3h9L3t5fWBdLFxuICAgICAgICAgICAgbWluem9vbTogaC5taW5ab29tLFxuICAgICAgICAgICAgbWF4em9vbTogaC5tYXhab29tLFxuICAgICAgICAgICAgYm91bmRzOiBbaC5taW5Mb24sIGgubWluTGF0LCBoLm1heExvbiwgaC5tYXhMYXRdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKC9wbXRpbGVzOlxcL1xcLyguKylcXC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKykvKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcmFtcy51cmwubWF0Y2gocmUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQTVRpbGVzIHByb3RvY29sIFVSTFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBtdGlsZXNVcmwgPSByZXN1bHRbMV07XG4gICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLnRpbGVzLmdldChwbXRpbGVzVXJsKTtcbiAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgUE1UaWxlcyhwbXRpbGVzVXJsKTtcbiAgICAgICAgdGhpcy50aWxlcy5zZXQocG10aWxlc1VybCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgeiA9IHJlc3VsdFsyXTtcbiAgICAgIGNvbnN0IHggPSByZXN1bHRbM107XG4gICAgICBjb25zdCB5ID0gcmVzdWx0WzRdO1xuICAgICAgY29uc3QgaGVhZGVyID0geWllbGQgaW5zdGFuY2UuZ2V0SGVhZGVyKCk7XG4gICAgICBjb25zdCByZXNwID0geWllbGQgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmdldFp4eSgreiwgK3gsICt5LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGlmIChyZXNwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkocmVzcC5kYXRhKSxcbiAgICAgICAgICBjYWNoZUNvbnRyb2w6IHJlc3AuY2FjaGVDb250cm9sLFxuICAgICAgICAgIGV4cGlyZXM6IHJlc3AuZXhwaXJlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGhlYWRlci50aWxlVHlwZSA9PT0gMSAvKiBNdnQgKi8pIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbmV3IFVpbnQ4QXJyYXkoKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCB9O1xuICAgIH0pO1xuICAgIHRoaXMudGlsZSA9IHYzY29tcGF0KHRoaXMudGlsZXY0KTtcbiAgICB0aGlzLnRpbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1ldGFkYXRhID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubWV0YWRhdGEpIHx8IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgUE1UaWxlc30gaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBwcm90b2NvbCBpbnN0YW5jZS5cbiAgICpcbiAgICogRm9yIHJlbW90ZSBmZXRjaCBzb3VyY2VzLCByZWZlcmVuY2VzIGluIE1hcExpYnJlIHN0eWxlcyBsaWtlIHBtdGlsZXM6Ly9odHRwOi8vLi4uXG4gICAqIHdpbGwgcmVzb2x2ZSB0byB0aGUgc2FtZSBpbnN0YW5jZSBpZiB0aGUgVVJMcyBtYXRjaC5cbiAgICovXG4gIGFkZChwKSB7XG4gICAgdGhpcy50aWxlcy5zZXQocC5zb3VyY2UuZ2V0S2V5KCksIHApO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHtAbGluayBQTVRpbGVzfSBpbnN0YW5jZSBieSBVUkwsIGZvciByZW1vdGUgUE1UaWxlcyBpbnN0YW5jZXMuXG4gICAqL1xuICBnZXQodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZXMuZ2V0KHVybCk7XG4gIH1cbn07XG5cbi8vIGluZGV4LnRzXG5mdW5jdGlvbiB0b051bShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIChoaWdoID4+PiAwKSAqIDQyOTQ5NjcyOTYgKyAobG93ID4+PiAwKTtcbn1cbmZ1bmN0aW9uIHJlYWRWYXJpbnRSZW1haW5kZXIobCwgcCkge1xuICBjb25zdCBidWYgPSBwLmJ1ZjtcbiAgbGV0IGIgPSBidWZbcC5wb3MrK107XG4gIGxldCBoID0gKGIgJiAxMTIpID4+IDQ7XG4gIGlmIChiIDwgMTI4KVxuICAgIHJldHVybiB0b051bShsLCBoKTtcbiAgYiA9IGJ1ZltwLnBvcysrXTtcbiAgaCB8PSAoYiAmIDEyNykgPDwgMztcbiAgaWYgKGIgPCAxMjgpXG4gICAgcmV0dXJuIHRvTnVtKGwsIGgpO1xuICBiID0gYnVmW3AucG9zKytdO1xuICBoIHw9IChiICYgMTI3KSA8PCAxMDtcbiAgaWYgKGIgPCAxMjgpXG4gICAgcmV0dXJuIHRvTnVtKGwsIGgpO1xuICBiID0gYnVmW3AucG9zKytdO1xuICBoIHw9IChiICYgMTI3KSA8PCAxNztcbiAgaWYgKGIgPCAxMjgpXG4gICAgcmV0dXJuIHRvTnVtKGwsIGgpO1xuICBiID0gYnVmW3AucG9zKytdO1xuICBoIHw9IChiICYgMTI3KSA8PCAyNDtcbiAgaWYgKGIgPCAxMjgpXG4gICAgcmV0dXJuIHRvTnVtKGwsIGgpO1xuICBiID0gYnVmW3AucG9zKytdO1xuICBoIHw9IChiICYgMSkgPDwgMzE7XG4gIGlmIChiIDwgMTI4KVxuICAgIHJldHVybiB0b051bShsLCBoKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdmFyaW50IG5vdCBtb3JlIHRoYW4gMTAgYnl0ZXNcIik7XG59XG5mdW5jdGlvbiByZWFkVmFyaW50KHApIHtcbiAgY29uc3QgYnVmID0gcC5idWY7XG4gIGxldCBiID0gYnVmW3AucG9zKytdO1xuICBsZXQgdmFsID0gYiAmIDEyNztcbiAgaWYgKGIgPCAxMjgpXG4gICAgcmV0dXJuIHZhbDtcbiAgYiA9IGJ1ZltwLnBvcysrXTtcbiAgdmFsIHw9IChiICYgMTI3KSA8PCA3O1xuICBpZiAoYiA8IDEyOClcbiAgICByZXR1cm4gdmFsO1xuICBiID0gYnVmW3AucG9zKytdO1xuICB2YWwgfD0gKGIgJiAxMjcpIDw8IDE0O1xuICBpZiAoYiA8IDEyOClcbiAgICByZXR1cm4gdmFsO1xuICBiID0gYnVmW3AucG9zKytdO1xuICB2YWwgfD0gKGIgJiAxMjcpIDw8IDIxO1xuICBpZiAoYiA8IDEyOClcbiAgICByZXR1cm4gdmFsO1xuICBiID0gYnVmW3AucG9zXTtcbiAgdmFsIHw9IChiICYgMTUpIDw8IDI4O1xuICByZXR1cm4gcmVhZFZhcmludFJlbWFpbmRlcih2YWwsIHApO1xufVxuZnVuY3Rpb24gcm90YXRlKG4sIHh5LCByeCwgcnkpIHtcbiAgaWYgKHJ5ID09PSAwKSB7XG4gICAgaWYgKHJ4ID09PSAxKSB7XG4gICAgICB4eVswXSA9IG4gLSAxIC0geHlbMF07XG4gICAgICB4eVsxXSA9IG4gLSAxIC0geHlbMV07XG4gICAgfVxuICAgIGNvbnN0IHQgPSB4eVswXTtcbiAgICB4eVswXSA9IHh5WzFdO1xuICAgIHh5WzFdID0gdDtcbiAgfVxufVxuZnVuY3Rpb24gaWRPbkxldmVsKHosIHBvcykge1xuICBjb25zdCBuID0gX19wb3coMiwgeik7XG4gIGxldCByeCA9IHBvcztcbiAgbGV0IHJ5ID0gcG9zO1xuICBsZXQgdCA9IHBvcztcbiAgY29uc3QgeHkgPSBbMCwgMF07XG4gIGxldCBzID0gMTtcbiAgd2hpbGUgKHMgPCBuKSB7XG4gICAgcnggPSAxICYgdCAvIDI7XG4gICAgcnkgPSAxICYgKHQgXiByeCk7XG4gICAgcm90YXRlKHMsIHh5LCByeCwgcnkpO1xuICAgIHh5WzBdICs9IHMgKiByeDtcbiAgICB4eVsxXSArPSBzICogcnk7XG4gICAgdCA9IHQgLyA0O1xuICAgIHMgKj0gMjtcbiAgfVxuICByZXR1cm4gW3osIHh5WzBdLCB4eVsxXV07XG59XG52YXIgdHpWYWx1ZXMgPSBbXG4gIDAsXG4gIDEsXG4gIDUsXG4gIDIxLFxuICA4NSxcbiAgMzQxLFxuICAxMzY1LFxuICA1NDYxLFxuICAyMTg0NSxcbiAgODczODEsXG4gIDM0OTUyNSxcbiAgMTM5ODEwMSxcbiAgNTU5MjQwNSxcbiAgMjIzNjk2MjEsXG4gIDg5NDc4NDg1LFxuICAzNTc5MTM5NDEsXG4gIDE0MzE2NTU3NjUsXG4gIDU3MjY2MjMwNjEsXG4gIDIyOTA2NDkyMjQ1LFxuICA5MTYyNTk2ODk4MSxcbiAgMzY2NTAzODc1OTI1LFxuICAxNDY2MDE1NTAzNzAxLFxuICA1ODY0MDYyMDE0ODA1LFxuICAyMzQ1NjI0ODA1OTIyMSxcbiAgOTM4MjQ5OTIyMzY4ODUsXG4gIDM3NTI5OTk2ODk0NzU0MSxcbiAgMTUwMTE5OTg3NTc5MDE2NVxuXTtcbmZ1bmN0aW9uIHp4eVRvVGlsZUlkKHosIHgsIHkpIHtcbiAgaWYgKHogPiAyNikge1xuICAgIHRocm93IEVycm9yKFwiVGlsZSB6b29tIGxldmVsIGV4Y2VlZHMgbWF4IHNhZmUgbnVtYmVyIGxpbWl0ICgyNilcIik7XG4gIH1cbiAgaWYgKHggPiBfX3BvdygyLCB6KSAtIDEgfHwgeSA+IF9fcG93KDIsIHopIC0gMSkge1xuICAgIHRocm93IEVycm9yKFwidGlsZSB4L3kgb3V0c2lkZSB6b29tIGxldmVsIGJvdW5kc1wiKTtcbiAgfVxuICBjb25zdCBhY2MgPSB0elZhbHVlc1t6XTtcbiAgY29uc3QgbiA9IF9fcG93KDIsIHopO1xuICBsZXQgcnggPSAwO1xuICBsZXQgcnkgPSAwO1xuICBsZXQgZCA9IDA7XG4gIGNvbnN0IHh5ID0gW3gsIHldO1xuICBsZXQgcyA9IG4gLyAyO1xuICB3aGlsZSAocyA+IDApIHtcbiAgICByeCA9ICh4eVswXSAmIHMpID4gMCA/IDEgOiAwO1xuICAgIHJ5ID0gKHh5WzFdICYgcykgPiAwID8gMSA6IDA7XG4gICAgZCArPSBzICogcyAqICgzICogcnggXiByeSk7XG4gICAgcm90YXRlKHMsIHh5LCByeCwgcnkpO1xuICAgIHMgPSBzIC8gMjtcbiAgfVxuICByZXR1cm4gYWNjICsgZDtcbn1cbmZ1bmN0aW9uIHRpbGVJZFRvWnh5KGkpIHtcbiAgbGV0IGFjYyA9IDA7XG4gIGNvbnN0IHogPSAwO1xuICBmb3IgKGxldCB6MiA9IDA7IHoyIDwgMjc7IHoyKyspIHtcbiAgICBjb25zdCBudW1UaWxlcyA9ICgxIDw8IHoyKSAqICgxIDw8IHoyKTtcbiAgICBpZiAoYWNjICsgbnVtVGlsZXMgPiBpKSB7XG4gICAgICByZXR1cm4gaWRPbkxldmVsKHoyLCBpIC0gYWNjKTtcbiAgICB9XG4gICAgYWNjICs9IG51bVRpbGVzO1xuICB9XG4gIHRocm93IEVycm9yKFwiVGlsZSB6b29tIGxldmVsIGV4Y2VlZHMgbWF4IHNhZmUgbnVtYmVyIGxpbWl0ICgyNilcIik7XG59XG52YXIgQ29tcHJlc3Npb24gPSAvKiBAX19QVVJFX18gKi8gKChDb21wcmVzc2lvbjIpID0+IHtcbiAgQ29tcHJlc3Npb24yW0NvbXByZXNzaW9uMltcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICBDb21wcmVzc2lvbjJbQ29tcHJlc3Npb24yW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIENvbXByZXNzaW9uMltDb21wcmVzc2lvbjJbXCJHemlwXCJdID0gMl0gPSBcIkd6aXBcIjtcbiAgQ29tcHJlc3Npb24yW0NvbXByZXNzaW9uMltcIkJyb3RsaVwiXSA9IDNdID0gXCJCcm90bGlcIjtcbiAgQ29tcHJlc3Npb24yW0NvbXByZXNzaW9uMltcIlpzdGRcIl0gPSA0XSA9IFwiWnN0ZFwiO1xuICByZXR1cm4gQ29tcHJlc3Npb24yO1xufSkoQ29tcHJlc3Npb24gfHwge30pO1xuZnVuY3Rpb24gZGVmYXVsdERlY29tcHJlc3MoYnVmLCBjb21wcmVzc2lvbikge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGlmIChjb21wcmVzc2lvbiA9PT0gMSAvKiBOb25lICovIHx8IGNvbXByZXNzaW9uID09PSAwIC8qIFVua25vd24gKi8pIHtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGlmIChjb21wcmVzc2lvbiA9PT0gMiAvKiBHemlwICovKSB7XG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuRGVjb21wcmVzc2lvblN0cmVhbSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZGVjb21wcmVzc1N5bmMobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVzcG9uc2UoYnVmKS5ib2R5O1xuICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gcmVhZCByZXNwb25zZSBzdHJlYW1cIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50OiBuZWVkZWQgdG8gZGV0ZWN0IERlY29tcHJlc3Npb25TdHJlYW0gaW4gYnJvd3Nlcitub2RlK2Nsb3VkZmxhcmUgd29ya2Vyc1xuICAgICAgICBuZXcgZ2xvYmFsVGhpcy5EZWNvbXByZXNzaW9uU3RyZWFtKFwiZ3ppcFwiKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzdWx0KS5hcnJheUJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbXByZXNzaW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkXCIpO1xuICB9KTtcbn1cbnZhciBUaWxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRpbGVUeXBlMikgPT4ge1xuICBUaWxlVHlwZTJbVGlsZVR5cGUyW1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XG4gIFRpbGVUeXBlMltUaWxlVHlwZTJbXCJNdnRcIl0gPSAxXSA9IFwiTXZ0XCI7XG4gIFRpbGVUeXBlMltUaWxlVHlwZTJbXCJQbmdcIl0gPSAyXSA9IFwiUG5nXCI7XG4gIFRpbGVUeXBlMltUaWxlVHlwZTJbXCJKcGVnXCJdID0gM10gPSBcIkpwZWdcIjtcbiAgVGlsZVR5cGUyW1RpbGVUeXBlMltcIldlYnBcIl0gPSA0XSA9IFwiV2VicFwiO1xuICBUaWxlVHlwZTJbVGlsZVR5cGUyW1wiQXZpZlwiXSA9IDVdID0gXCJBdmlmXCI7XG4gIHJldHVybiBUaWxlVHlwZTI7XG59KShUaWxlVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiB0aWxlVHlwZUV4dCh0KSB7XG4gIGlmICh0ID09PSAxIC8qIE12dCAqLylcbiAgICByZXR1cm4gXCIubXZ0XCI7XG4gIGlmICh0ID09PSAyIC8qIFBuZyAqLylcbiAgICByZXR1cm4gXCIucG5nXCI7XG4gIGlmICh0ID09PSAzIC8qIEpwZWcgKi8pXG4gICAgcmV0dXJuIFwiLmpwZ1wiO1xuICBpZiAodCA9PT0gNCAvKiBXZWJwICovKVxuICAgIHJldHVybiBcIi53ZWJwXCI7XG4gIGlmICh0ID09PSA1IC8qIEF2aWYgKi8pXG4gICAgcmV0dXJuIFwiLmF2aWZcIjtcbiAgcmV0dXJuIFwiXCI7XG59XG52YXIgSEVBREVSX1NJWkVfQllURVMgPSAxMjc7XG5mdW5jdGlvbiBmaW5kVGlsZShlbnRyaWVzLCB0aWxlSWQpIHtcbiAgbGV0IG0gPSAwO1xuICBsZXQgbiA9IGVudHJpZXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKG0gPD0gbikge1xuICAgIGNvbnN0IGsgPSBuICsgbSA+PiAxO1xuICAgIGNvbnN0IGNtcCA9IHRpbGVJZCAtIGVudHJpZXNba10udGlsZUlkO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBtID0gayArIDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICBuID0gayAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAobiA+PSAwKSB7XG4gICAgaWYgKGVudHJpZXNbbl0ucnVuTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZW50cmllc1tuXTtcbiAgICB9XG4gICAgaWYgKHRpbGVJZCAtIGVudHJpZXNbbl0udGlsZUlkIDwgZW50cmllc1tuXS5ydW5MZW5ndGgpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW25dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBGaWxlU291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihmaWxlKSB7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZS5uYW1lO1xuICB9XG4gIGdldEJ5dGVzKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGJsb2IgPSB0aGlzLmZpbGUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgY29uc3QgYSA9IHlpZWxkIGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICAgIHJldHVybiB7IGRhdGE6IGEgfTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBGZXRjaFNvdXJjZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodXJsLCBjdXN0b21IZWFkZXJzID0gbmV3IEhlYWRlcnMoKSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuY3VzdG9tSGVhZGVycyA9IGN1c3RvbUhlYWRlcnM7XG4gICAgdGhpcy5tdXN0UmVsb2FkID0gZmFsc2U7XG4gICAgbGV0IHVzZXJBZ2VudCA9IFwiXCI7XG4gICAgaWYgKFwibmF2aWdhdG9yXCIgaW4gZ2xvYmFsVGhpcykge1xuICAgICAgdXNlckFnZW50ID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IGlzV2luZG93cyA9IHVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93c1wiKSA+IC0xO1xuICAgIGNvbnN0IGlzQ2hyb21pdW1CYXNlZCA9IC9DaHJvbWV8Q2hyb21pdW18RWRnfE9QUnxCcmF2ZS8udGVzdCh1c2VyQWdlbnQpO1xuICAgIHRoaXMuY2hyb21lV2luZG93c05vQ2FjaGUgPSBmYWxzZTtcbiAgICBpZiAoaXNXaW5kb3dzICYmIGlzQ2hyb21pdW1CYXNlZCkge1xuICAgICAgdGhpcy5jaHJvbWVXaW5kb3dzTm9DYWNoZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy51cmw7XG4gIH1cbiAgLyoqXG4gICAqIE11dGF0ZSB0aGUgY3VzdG9tIFtIZWFkZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGVhZGVycykgc2V0IGZvciBhbGwgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBhcmNoaXZlLlxuICAgKi9cbiAgc2V0SGVhZGVycyhjdXN0b21IZWFkZXJzKSB7XG4gICAgdGhpcy5jdXN0b21IZWFkZXJzID0gY3VzdG9tSGVhZGVycztcbiAgfVxuICBnZXRCeXRlcyhvZmZzZXQsIGxlbmd0aCwgcGFzc2VkU2lnbmFsLCBldGFnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBjb250cm9sbGVyO1xuICAgICAgbGV0IHNpZ25hbDtcbiAgICAgIGlmIChwYXNzZWRTaWduYWwpIHtcbiAgICAgICAgc2lnbmFsID0gcGFzc2VkU2lnbmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuY3VzdG9tSGVhZGVycyk7XG4gICAgICByZXF1ZXN0SGVhZGVycy5zZXQoXCJyYW5nZVwiLCBgYnl0ZXM9JHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RoIC0gMX1gKTtcbiAgICAgIGxldCBjYWNoZTtcbiAgICAgIGlmICh0aGlzLm11c3RSZWxvYWQpIHtcbiAgICAgICAgY2FjaGUgPSBcInJlbG9hZFwiO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNocm9tZVdpbmRvd3NOb0NhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gXCJuby1zdG9yZVwiO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3AgPSB5aWVsZCBmZXRjaCh0aGlzLnVybCwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVyc1xuICAgICAgICAvL2Jpb21lLWlnbm9yZSBsaW50OiBcImNhY2hlXCIgaXMgaW5jb21wYXRpYmxlIGJldHdlZW4gY2xvdWRmbGFyZSB3b3JrZXJzIGFuZCBicm93c2VyXG4gICAgICB9KTtcbiAgICAgIGlmIChvZmZzZXQgPT09IDAgJiYgcmVzcC5zdGF0dXMgPT09IDQxNikge1xuICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSByZXNwLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgICAgaWYgKCFjb250ZW50UmFuZ2UgfHwgIWNvbnRlbnRSYW5nZS5zdGFydHNXaXRoKFwiYnl0ZXMgKi9cIikpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIk1pc3NpbmcgY29udGVudC1sZW5ndGggb24gNDE2IHJlc3BvbnNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9ICtjb250ZW50UmFuZ2Uuc3Vic3RyKDgpO1xuICAgICAgICByZXNwID0geWllbGQgZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgY2FjaGU6IFwicmVsb2FkXCIsXG4gICAgICAgICAgaGVhZGVyczogeyByYW5nZTogYGJ5dGVzPTAtJHthY3R1YWxMZW5ndGggLSAxfWAgfVxuICAgICAgICAgIC8vYmlvbWUtaWdub3JlIGxpbnQ6IFwiY2FjaGVcIiBpcyBpbmNvbXBhdGlibGUgYmV0d2VlbiBjbG91ZGZsYXJlIHdvcmtlcnMgYW5kIGJyb3dzZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3RXRhZyA9IHJlc3AuaGVhZGVycy5nZXQoXCJFdGFnXCIpO1xuICAgICAgaWYgKG5ld0V0YWcgPT0gbnVsbCA/IHZvaWQgMCA6IG5ld0V0YWcuc3RhcnRzV2l0aChcIlcvXCIpKSB7XG4gICAgICAgIG5ld0V0YWcgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MTYgfHwgZXRhZyAmJiBuZXdFdGFnICYmIG5ld0V0YWcgIT09IGV0YWcpIHtcbiAgICAgICAgdGhpcy5tdXN0UmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEV0YWdNaXNtYXRjaChcbiAgICAgICAgICBgU2VydmVyIHJldHVybmVkIG5vbi1tYXRjaGluZyBFVGFnICR7ZXRhZ30gYWZ0ZXIgb25lIHJldHJ5LiBDaGVjayBicm93c2VyIGV4dGVuc2lvbnMgYW5kIHNlcnZlcnMgZm9yIGlzc3VlcyB0aGF0IG1heSBhZmZlY3QgY29ycmVjdCBFVGFnIGhlYWRlcnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3Auc3RhdHVzID49IDMwMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQmFkIHJlc3BvbnNlIGNvZGU6ICR7cmVzcC5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpO1xuICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSAyMDAgJiYgKCFjb250ZW50TGVuZ3RoIHx8ICtjb250ZW50TGVuZ3RoID4gbGVuZ3RoKSkge1xuICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2VydmVyIHJldHVybmVkIG5vIGNvbnRlbnQtbGVuZ3RoIGhlYWRlciBvciBjb250ZW50LWxlbmd0aCBleGNlZWRpbmcgcmVxdWVzdC4gQ2hlY2sgdGhhdCB5b3VyIHN0b3JhZ2UgYmFja2VuZCBzdXBwb3J0cyBIVFRQIEJ5dGUgU2VydmluZy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgYSA9IHlpZWxkIHJlc3AuYXJyYXlCdWZmZXIoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGEsXG4gICAgICAgIGV0YWc6IG5ld0V0YWcgfHwgdm9pZCAwLFxuICAgICAgICBjYWNoZUNvbnRyb2w6IHJlc3AuaGVhZGVycy5nZXQoXCJDYWNoZS1Db250cm9sXCIpIHx8IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogcmVzcC5oZWFkZXJzLmdldChcIkV4cGlyZXNcIikgfHwgdm9pZCAwXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0VWludDY0KHYsIG9mZnNldCkge1xuICBjb25zdCB3aCA9IHYuZ2V0VWludDMyKG9mZnNldCArIDQsIHRydWUpO1xuICBjb25zdCB3bCA9IHYuZ2V0VWludDMyKG9mZnNldCArIDAsIHRydWUpO1xuICByZXR1cm4gd2ggKiBfX3BvdygyLCAzMikgKyB3bDtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9IZWFkZXIoYnl0ZXMsIGV0YWcpIHtcbiAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhieXRlcyk7XG4gIGNvbnN0IHNwZWNWZXJzaW9uID0gdi5nZXRVaW50OCg3KTtcbiAgaWYgKHNwZWNWZXJzaW9uID4gMykge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYEFyY2hpdmUgaXMgc3BlYyB2ZXJzaW9uICR7c3BlY1ZlcnNpb259IGJ1dCB0aGlzIGxpYnJhcnkgc3VwcG9ydHMgdXAgdG8gc3BlYyB2ZXJzaW9uIDNgXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNWZXJzaW9uLFxuICAgIHJvb3REaXJlY3RvcnlPZmZzZXQ6IGdldFVpbnQ2NCh2LCA4KSxcbiAgICByb290RGlyZWN0b3J5TGVuZ3RoOiBnZXRVaW50NjQodiwgMTYpLFxuICAgIGpzb25NZXRhZGF0YU9mZnNldDogZ2V0VWludDY0KHYsIDI0KSxcbiAgICBqc29uTWV0YWRhdGFMZW5ndGg6IGdldFVpbnQ2NCh2LCAzMiksXG4gICAgbGVhZkRpcmVjdG9yeU9mZnNldDogZ2V0VWludDY0KHYsIDQwKSxcbiAgICBsZWFmRGlyZWN0b3J5TGVuZ3RoOiBnZXRVaW50NjQodiwgNDgpLFxuICAgIHRpbGVEYXRhT2Zmc2V0OiBnZXRVaW50NjQodiwgNTYpLFxuICAgIHRpbGVEYXRhTGVuZ3RoOiBnZXRVaW50NjQodiwgNjQpLFxuICAgIG51bUFkZHJlc3NlZFRpbGVzOiBnZXRVaW50NjQodiwgNzIpLFxuICAgIG51bVRpbGVFbnRyaWVzOiBnZXRVaW50NjQodiwgODApLFxuICAgIG51bVRpbGVDb250ZW50czogZ2V0VWludDY0KHYsIDg4KSxcbiAgICBjbHVzdGVyZWQ6IHYuZ2V0VWludDgoOTYpID09PSAxLFxuICAgIGludGVybmFsQ29tcHJlc3Npb246IHYuZ2V0VWludDgoOTcpLFxuICAgIHRpbGVDb21wcmVzc2lvbjogdi5nZXRVaW50OCg5OCksXG4gICAgdGlsZVR5cGU6IHYuZ2V0VWludDgoOTkpLFxuICAgIG1pblpvb206IHYuZ2V0VWludDgoMTAwKSxcbiAgICBtYXhab29tOiB2LmdldFVpbnQ4KDEwMSksXG4gICAgbWluTG9uOiB2LmdldEludDMyKDEwMiwgdHJ1ZSkgLyAxZTcsXG4gICAgbWluTGF0OiB2LmdldEludDMyKDEwNiwgdHJ1ZSkgLyAxZTcsXG4gICAgbWF4TG9uOiB2LmdldEludDMyKDExMCwgdHJ1ZSkgLyAxZTcsXG4gICAgbWF4TGF0OiB2LmdldEludDMyKDExNCwgdHJ1ZSkgLyAxZTcsXG4gICAgY2VudGVyWm9vbTogdi5nZXRVaW50OCgxMTgpLFxuICAgIGNlbnRlckxvbjogdi5nZXRJbnQzMigxMTksIHRydWUpIC8gMWU3LFxuICAgIGNlbnRlckxhdDogdi5nZXRJbnQzMigxMjMsIHRydWUpIC8gMWU3LFxuICAgIGV0YWdcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplSW5kZXgoYnVmZmVyKSB7XG4gIGNvbnN0IHAgPSB7IGJ1ZjogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcG9zOiAwIH07XG4gIGNvbnN0IG51bUVudHJpZXMgPSByZWFkVmFyaW50KHApO1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGxldCBsYXN0SWQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgIGNvbnN0IHYgPSByZWFkVmFyaW50KHApO1xuICAgIGVudHJpZXMucHVzaCh7IHRpbGVJZDogbGFzdElkICsgdiwgb2Zmc2V0OiAwLCBsZW5ndGg6IDAsIHJ1bkxlbmd0aDogMSB9KTtcbiAgICBsYXN0SWQgKz0gdjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgIGVudHJpZXNbaV0ucnVuTGVuZ3RoID0gcmVhZFZhcmludChwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgIGVudHJpZXNbaV0ubGVuZ3RoID0gcmVhZFZhcmludChwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgIGNvbnN0IHYgPSByZWFkVmFyaW50KHApO1xuICAgIGlmICh2ID09PSAwICYmIGkgPiAwKSB7XG4gICAgICBlbnRyaWVzW2ldLm9mZnNldCA9IGVudHJpZXNbaSAtIDFdLm9mZnNldCArIGVudHJpZXNbaSAtIDFdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cmllc1tpXS5vZmZzZXQgPSB2IC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5mdW5jdGlvbiBkZXRlY3RWZXJzaW9uKGEpIHtcbiAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhhKTtcbiAgaWYgKHYuZ2V0VWludDE2KDIsIHRydWUpID09PSAyKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJQTVRpbGVzIHNwZWMgdmVyc2lvbiAyIGhhcyBiZWVuIGRlcHJlY2F0ZWQ7IHBsZWFzZSBzZWUgZ2l0aHViLmNvbS9wcm90b21hcHMvUE1UaWxlcyBmb3IgdG9vbHMgdG8gdXBncmFkZVwiXG4gICAgKTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICBpZiAodi5nZXRVaW50MTYoMiwgdHJ1ZSkgPT09IDEpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlBNVGlsZXMgc3BlYyB2ZXJzaW9uIDEgaGFzIGJlZW4gZGVwcmVjYXRlZDsgcGxlYXNlIHNlZSBnaXRodWIuY29tL3Byb3RvbWFwcy9QTVRpbGVzIGZvciB0b29scyB0byB1cGdyYWRlXCJcbiAgICApO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAzO1xufVxudmFyIEV0YWdNaXNtYXRjaCA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcbmZ1bmN0aW9uIGdldEhlYWRlckFuZFJvb3Qoc291cmNlLCBkZWNvbXByZXNzKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcmVzcCA9IHlpZWxkIHNvdXJjZS5nZXRCeXRlcygwLCAxNjM4NCk7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhyZXNwLmRhdGEpO1xuICAgIGlmICh2LmdldFVpbnQxNigwLCB0cnVlKSAhPT0gMTk3OTIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIG1hZ2ljIG51bWJlciBmb3IgUE1UaWxlcyBhcmNoaXZlXCIpO1xuICAgIH1cbiAgICBpZiAoZGV0ZWN0VmVyc2lvbihyZXNwLmRhdGEpIDwgMykge1xuICAgICAgcmV0dXJuIFt5aWVsZCB2Ml9kZWZhdWx0LmdldEhlYWRlcihzb3VyY2UpXTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyRGF0YSA9IHJlc3AuZGF0YS5zbGljZSgwLCBIRUFERVJfU0laRV9CWVRFUyk7XG4gICAgY29uc3QgaGVhZGVyID0gYnl0ZXNUb0hlYWRlcihoZWFkZXJEYXRhLCByZXNwLmV0YWcpO1xuICAgIGNvbnN0IHJvb3REaXJEYXRhID0gcmVzcC5kYXRhLnNsaWNlKFxuICAgICAgaGVhZGVyLnJvb3REaXJlY3RvcnlPZmZzZXQsXG4gICAgICBoZWFkZXIucm9vdERpcmVjdG9yeU9mZnNldCArIGhlYWRlci5yb290RGlyZWN0b3J5TGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBkaXJLZXkgPSBgJHtzb3VyY2UuZ2V0S2V5KCl9fCR7aGVhZGVyLmV0YWcgfHwgXCJcIn18JHtoZWFkZXIucm9vdERpcmVjdG9yeU9mZnNldH18JHtoZWFkZXIucm9vdERpcmVjdG9yeUxlbmd0aH1gO1xuICAgIGNvbnN0IHJvb3REaXIgPSBkZXNlcmlhbGl6ZUluZGV4KFxuICAgICAgeWllbGQgZGVjb21wcmVzcyhyb290RGlyRGF0YSwgaGVhZGVyLmludGVybmFsQ29tcHJlc3Npb24pXG4gICAgKTtcbiAgICByZXR1cm4gW2hlYWRlciwgW2RpcktleSwgcm9vdERpci5sZW5ndGgsIHJvb3REaXJdXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXREaXJlY3Rvcnkoc291cmNlLCBkZWNvbXByZXNzLCBvZmZzZXQsIGxlbmd0aCwgaGVhZGVyKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcmVzcCA9IHlpZWxkIHNvdXJjZS5nZXRCeXRlcyhvZmZzZXQsIGxlbmd0aCwgdm9pZCAwLCBoZWFkZXIuZXRhZyk7XG4gICAgY29uc3QgZGF0YSA9IHlpZWxkIGRlY29tcHJlc3MocmVzcC5kYXRhLCBoZWFkZXIuaW50ZXJuYWxDb21wcmVzc2lvbik7XG4gICAgY29uc3QgZGlyZWN0b3J5ID0gZGVzZXJpYWxpemVJbmRleChkYXRhKTtcbiAgICBpZiAoZGlyZWN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgZGlyZWN0b3J5IGlzIGludmFsaWRcIik7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rvcnk7XG4gIH0pO1xufVxudmFyIFJlc29sdmVkVmFsdWVDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVFbnRyaWVzID0gMTAwLCBwcmVmZXRjaCA9IHRydWUsIGRlY29tcHJlc3MgPSBkZWZhdWx0RGVjb21wcmVzcykge1xuICAgIHRoaXMuY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWF4Q2FjaGVFbnRyaWVzID0gbWF4Q2FjaGVFbnRyaWVzO1xuICAgIHRoaXMuY291bnRlciA9IDE7XG4gICAgdGhpcy5kZWNvbXByZXNzID0gZGVjb21wcmVzcztcbiAgfVxuICBnZXRIZWFkZXIoc291cmNlKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc291cmNlLmdldEtleSgpO1xuICAgICAgY29uc3QgY2FjaGVWYWx1ZSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZVZhbHVlKSB7XG4gICAgICAgIGNhY2hlVmFsdWUubGFzdFVzZWQgPSB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhY2hlVmFsdWUuZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCBnZXRIZWFkZXJBbmRSb290KHNvdXJjZSwgdGhpcy5kZWNvbXByZXNzKTtcbiAgICAgIGlmIChyZXNbMV0pIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQocmVzWzFdWzBdLCB7XG4gICAgICAgICAgbGFzdFVzZWQ6IHRoaXMuY291bnRlcisrLFxuICAgICAgICAgIGRhdGE6IHJlc1sxXVsyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGxhc3RVc2VkOiB0aGlzLmNvdW50ZXIrKyxcbiAgICAgICAgZGF0YTogcmVzWzBdXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJ1bmUoKTtcbiAgICAgIHJldHVybiByZXNbMF07XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGlyZWN0b3J5KHNvdXJjZSwgb2Zmc2V0LCBsZW5ndGgsIGhlYWRlcikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke3NvdXJjZS5nZXRLZXkoKX18JHtoZWFkZXIuZXRhZyB8fCBcIlwifXwke29mZnNldH18JHtsZW5ndGh9YDtcbiAgICAgIGNvbnN0IGNhY2hlVmFsdWUgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVWYWx1ZSkge1xuICAgICAgICBjYWNoZVZhbHVlLmxhc3RVc2VkID0gdGhpcy5jb3VudGVyKys7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYWNoZVZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0b3J5ID0geWllbGQgZ2V0RGlyZWN0b3J5KFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRoaXMuZGVjb21wcmVzcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGhlYWRlclxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGxhc3RVc2VkOiB0aGlzLmNvdW50ZXIrKyxcbiAgICAgICAgZGF0YTogZGlyZWN0b3J5XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJ1bmUoKTtcbiAgICAgIHJldHVybiBkaXJlY3Rvcnk7XG4gICAgfSk7XG4gIH1cbiAgLy8gZm9yIHYyIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGdldEFycmF5QnVmZmVyKHNvdXJjZSwgb2Zmc2V0LCBsZW5ndGgsIGhlYWRlcikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke3NvdXJjZS5nZXRLZXkoKX18JHtoZWFkZXIuZXRhZyB8fCBcIlwifXwke29mZnNldH18JHtsZW5ndGh9YDtcbiAgICAgIGNvbnN0IGNhY2hlVmFsdWUgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVWYWx1ZSkge1xuICAgICAgICBjYWNoZVZhbHVlLmxhc3RVc2VkID0gdGhpcy5jb3VudGVyKys7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBjYWNoZVZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIHNvdXJjZS5nZXRCeXRlcyhvZmZzZXQsIGxlbmd0aCwgdm9pZCAwLCBoZWFkZXIuZXRhZyk7XG4gICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwge1xuICAgICAgICBsYXN0VXNlZDogdGhpcy5jb3VudGVyKyssXG4gICAgICAgIGRhdGE6IHJlc3AuZGF0YVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBydW5lKCk7XG4gICAgICByZXR1cm4gcmVzcC5kYXRhO1xuICAgIH0pO1xuICB9XG4gIHBydW5lKCkge1xuICAgIGlmICh0aGlzLmNhY2hlLnNpemUgPiB0aGlzLm1heENhY2hlRW50cmllcykge1xuICAgICAgbGV0IG1pblVzZWQgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtaW5LZXkgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNhY2hlLmZvckVhY2goKGNhY2hlVmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoY2FjaGVWYWx1ZS5sYXN0VXNlZCA8IG1pblVzZWQpIHtcbiAgICAgICAgICBtaW5Vc2VkID0gY2FjaGVWYWx1ZS5sYXN0VXNlZDtcbiAgICAgICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG1pbktleSkge1xuICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShtaW5LZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlKHNvdXJjZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZShzb3VyY2UuZ2V0S2V5KCkpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIFNoYXJlZFByb21pc2VDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVFbnRyaWVzID0gMTAwLCBwcmVmZXRjaCA9IHRydWUsIGRlY29tcHJlc3MgPSBkZWZhdWx0RGVjb21wcmVzcykge1xuICAgIHRoaXMuY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW52YWxpZGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tYXhDYWNoZUVudHJpZXMgPSBtYXhDYWNoZUVudHJpZXM7XG4gICAgdGhpcy5jb3VudGVyID0gMTtcbiAgICB0aGlzLmRlY29tcHJlc3MgPSBkZWNvbXByZXNzO1xuICB9XG4gIGdldEhlYWRlcihzb3VyY2UpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBzb3VyY2UuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjYWNoZVZhbHVlID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlVmFsdWUpIHtcbiAgICAgICAgY2FjaGVWYWx1ZS5sYXN0VXNlZCA9IHRoaXMuY291bnRlcisrO1xuICAgICAgICBjb25zdCBkYXRhID0geWllbGQgY2FjaGVWYWx1ZS5kYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGdldEhlYWRlckFuZFJvb3Qoc291cmNlLCB0aGlzLmRlY29tcHJlc3MpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGlmIChyZXNbMV0pIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHJlc1sxXVswXSwge1xuICAgICAgICAgICAgICBsYXN0VXNlZDogdGhpcy5jb3VudGVyKyssXG4gICAgICAgICAgICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShyZXNbMV1bMl0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXNbMF0pO1xuICAgICAgICAgIHRoaXMucHJ1bmUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgeyBsYXN0VXNlZDogdGhpcy5jb3VudGVyKyssIGRhdGE6IHAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9KTtcbiAgfVxuICBnZXREaXJlY3Rvcnkoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgaGVhZGVyKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7c291cmNlLmdldEtleSgpfXwke2hlYWRlci5ldGFnIHx8IFwiXCJ9fCR7b2Zmc2V0fXwke2xlbmd0aH1gO1xuICAgICAgY29uc3QgY2FjaGVWYWx1ZSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZVZhbHVlKSB7XG4gICAgICAgIGNhY2hlVmFsdWUubGFzdFVzZWQgPSB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGNhY2hlVmFsdWUuZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBnZXREaXJlY3Rvcnkoc291cmNlLCB0aGlzLmRlY29tcHJlc3MsIG9mZnNldCwgbGVuZ3RoLCBoZWFkZXIpLnRoZW4oKGRpcmVjdG9yeSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZGlyZWN0b3J5KTtcbiAgICAgICAgICB0aGlzLnBydW5lKCk7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWNoZS5zZXQoY2FjaGVLZXksIHsgbGFzdFVzZWQ6IHRoaXMuY291bnRlcisrLCBkYXRhOiBwIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gIH1cbiAgLy8gZm9yIHYyIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGdldEFycmF5QnVmZmVyKHNvdXJjZSwgb2Zmc2V0LCBsZW5ndGgsIGhlYWRlcikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke3NvdXJjZS5nZXRLZXkoKX18JHtoZWFkZXIuZXRhZyB8fCBcIlwifXwke29mZnNldH18JHtsZW5ndGh9YDtcbiAgICAgIGNvbnN0IGNhY2hlVmFsdWUgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVWYWx1ZSkge1xuICAgICAgICBjYWNoZVZhbHVlLmxhc3RVc2VkID0gdGhpcy5jb3VudGVyKys7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBjYWNoZVZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc291cmNlLmdldEJ5dGVzKG9mZnNldCwgbGVuZ3RoLCB2b2lkIDAsIGhlYWRlci5ldGFnKS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwLmRhdGEpO1xuICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wcnVuZSgpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCB7IGxhc3RVc2VkOiB0aGlzLmNvdW50ZXIrKywgZGF0YTogcCB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0pO1xuICB9XG4gIHBydW5lKCkge1xuICAgIGlmICh0aGlzLmNhY2hlLnNpemUgPj0gdGhpcy5tYXhDYWNoZUVudHJpZXMpIHtcbiAgICAgIGxldCBtaW5Vc2VkID0gSW5maW5pdHk7XG4gICAgICBsZXQgbWluS2V5ID0gdm9pZCAwO1xuICAgICAgdGhpcy5jYWNoZS5mb3JFYWNoKChjYWNoZVZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlVmFsdWUubGFzdFVzZWQgPCBtaW5Vc2VkKSB7XG4gICAgICAgICAgbWluVXNlZCA9IGNhY2hlVmFsdWUubGFzdFVzZWQ7XG4gICAgICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChtaW5LZXkpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUobWluS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YWxpZGF0ZShzb3VyY2UpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qga2V5ID0gc291cmNlLmdldEtleSgpO1xuICAgICAgaWYgKHRoaXMuaW52YWxpZGF0aW9ucy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4geWllbGQgdGhpcy5pbnZhbGlkYXRpb25zLmdldChrZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoc291cmNlLmdldEtleSgpKTtcbiAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0SGVhZGVyKHNvdXJjZSkudGhlbigoaCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbnZhbGlkYXRpb25zLnNldChrZXksIHApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIFBNVGlsZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgY2FjaGUsIGRlY29tcHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgRmV0Y2hTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChkZWNvbXByZXNzKSB7XG4gICAgICB0aGlzLmRlY29tcHJlc3MgPSBkZWNvbXByZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29tcHJlc3MgPSBkZWZhdWx0RGVjb21wcmVzcztcbiAgICB9XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgU2hhcmVkUHJvbWlzZUNhY2hlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGhlYWRlciBvZiB0aGUgYXJjaGl2ZSxcbiAgICogaW5jbHVkaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGlsZSB0eXBlLCBtaW4vbWF4IHpvb20sIGJvdW5kcywgYW5kIHN1bW1hcnkgc3RhdGlzdGljcy5cbiAgICovXG4gIGdldEhlYWRlcigpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2FjaGUuZ2V0SGVhZGVyKHRoaXMuc291cmNlKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGhpZGRlbiAqL1xuICBnZXRaeHlBdHRlbXB0KHosIHgsIHksIHNpZ25hbCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0aWxlSWQgPSB6eHlUb1RpbGVJZCh6LCB4LCB5KTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IHlpZWxkIHRoaXMuY2FjaGUuZ2V0SGVhZGVyKHRoaXMuc291cmNlKTtcbiAgICAgIGlmIChoZWFkZXIuc3BlY1ZlcnNpb24gPCAzKSB7XG4gICAgICAgIHJldHVybiB2Ml9kZWZhdWx0LmdldFp4eShoZWFkZXIsIHRoaXMuc291cmNlLCB0aGlzLmNhY2hlLCB6LCB4LCB5LCBzaWduYWwpO1xuICAgICAgfVxuICAgICAgaWYgKHogPCBoZWFkZXIubWluWm9vbSB8fCB6ID4gaGVhZGVyLm1heFpvb20pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGxldCBkTyA9IGhlYWRlci5yb290RGlyZWN0b3J5T2Zmc2V0O1xuICAgICAgbGV0IGRMID0gaGVhZGVyLnJvb3REaXJlY3RvcnlMZW5ndGg7XG4gICAgICBmb3IgKGxldCBkZXB0aCA9IDA7IGRlcHRoIDw9IDM7IGRlcHRoKyspIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0geWllbGQgdGhpcy5jYWNoZS5nZXREaXJlY3RvcnkoXG4gICAgICAgICAgdGhpcy5zb3VyY2UsXG4gICAgICAgICAgZE8sXG4gICAgICAgICAgZEwsXG4gICAgICAgICAgaGVhZGVyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZmluZFRpbGUoZGlyZWN0b3J5LCB0aWxlSWQpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkucnVuTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIHRoaXMuc291cmNlLmdldEJ5dGVzKFxuICAgICAgICAgICAgICBoZWFkZXIudGlsZURhdGFPZmZzZXQgKyBlbnRyeS5vZmZzZXQsXG4gICAgICAgICAgICAgIGVudHJ5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXIuZXRhZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHlpZWxkIHRoaXMuZGVjb21wcmVzcyhyZXNwLmRhdGEsIGhlYWRlci50aWxlQ29tcHJlc3Npb24pLFxuICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHJlc3AuY2FjaGVDb250cm9sLFxuICAgICAgICAgICAgICBleHBpcmVzOiByZXNwLmV4cGlyZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRPID0gaGVhZGVyLmxlYWZEaXJlY3RvcnlPZmZzZXQgKyBlbnRyeS5vZmZzZXQ7XG4gICAgICAgICAgZEwgPSBlbnRyeS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJNYXhpbXVtIGRpcmVjdG9yeSBkZXB0aCBleGNlZWRlZFwiKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJpbWFyeSBtZXRob2QgdG8gZ2V0IGEgc2luZ2xlIHRpbGUncyBieXRlcyBmcm9tIGFuIGFyY2hpdmUuXG4gICAqXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSB0aWxlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBhcmNoaXZlLlxuICAgKi9cbiAgZ2V0Wnh5KHosIHgsIHksIHNpZ25hbCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRaeHlBdHRlbXB0KHosIHgsIHksIHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXRhZ01pc21hdGNoKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZS5pbnZhbGlkYXRlKHRoaXMuc291cmNlKTtcbiAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRaeHlBdHRlbXB0KHosIHgsIHksIHNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKiogQGhpZGRlbiAqL1xuICBnZXRNZXRhZGF0YUF0dGVtcHQoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IHlpZWxkIHRoaXMuY2FjaGUuZ2V0SGVhZGVyKHRoaXMuc291cmNlKTtcbiAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCB0aGlzLnNvdXJjZS5nZXRCeXRlcyhcbiAgICAgICAgaGVhZGVyLmpzb25NZXRhZGF0YU9mZnNldCxcbiAgICAgICAgaGVhZGVyLmpzb25NZXRhZGF0YUxlbmd0aCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBoZWFkZXIuZXRhZ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlY29tcHJlc3NlZCA9IHlpZWxkIHRoaXMuZGVjb21wcmVzcyhcbiAgICAgICAgcmVzcC5kYXRhLFxuICAgICAgICBoZWFkZXIuaW50ZXJuYWxDb21wcmVzc2lvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlYyA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjLmRlY29kZShkZWNvbXByZXNzZWQpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmJpdHJhcnkgSlNPTiBtZXRhZGF0YSBvZiB0aGUgYXJjaGl2ZS5cbiAgICovXG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRNZXRhZGF0YUF0dGVtcHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFdGFnTWlzbWF0Y2gpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlLmludmFsaWRhdGUodGhpcy5zb3VyY2UpO1xuICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldE1ldGFkYXRhQXR0ZW1wdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFtUaWxlSlNPTl0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC90aWxlanNvbi1zcGVjKSBvYmplY3QuXG4gICAqXG4gICAqIGJhc2VUaWxlc1VybCBpcyB0aGUgZGVzaXJlZCB0aWxlcyBVUkwsIGV4Y2x1ZGluZyB0aGUgc3VmZml4IGAve3p9L3t4fS97eX0ue2V4dH1gLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGRlc2lyZWQgVVJMIGlzIGBodHRwOi8vZXhhbXBsZS5jb20vdGlsZXNldC97en0ve3h9L3t5fS5tdnRgLFxuICAgKiB0aGUgYmFzZVRpbGVzVXJsIHNob3VsZCBiZSBgaHR0cHM6Ly9leGFtcGxlLmNvbS90aWxlc2V0YC5cbiAgICovXG4gIGdldFRpbGVKc29uKGJhc2VUaWxlc1VybCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSB5aWVsZCB0aGlzLmdldEhlYWRlcigpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB5aWVsZCB0aGlzLmdldE1ldGFkYXRhKCk7XG4gICAgICBjb25zdCBleHQgPSB0aWxlVHlwZUV4dChoZWFkZXIudGlsZVR5cGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGlsZWpzb246IFwiMy4wLjBcIixcbiAgICAgICAgc2NoZW1lOiBcInh5elwiLFxuICAgICAgICB0aWxlczogW2Ake2Jhc2VUaWxlc1VybH0ve3p9L3t4fS97eX0ke2V4dH1gXSxcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQ6IFRpbGVKU09OIHNwZWNcbiAgICAgICAgdmVjdG9yX2xheWVyczogbWV0YWRhdGEudmVjdG9yX2xheWVycyxcbiAgICAgICAgYXR0cmlidXRpb246IG1ldGFkYXRhLmF0dHJpYnV0aW9uLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWV0YWRhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUsXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb24sXG4gICAgICAgIGJvdW5kczogW2hlYWRlci5taW5Mb24sIGhlYWRlci5taW5MYXQsIGhlYWRlci5tYXhMb24sIGhlYWRlci5tYXhMYXRdLFxuICAgICAgICBjZW50ZXI6IFtoZWFkZXIuY2VudGVyTG9uLCBoZWFkZXIuY2VudGVyTGF0LCBoZWFkZXIuY2VudGVyWm9vbV0sXG4gICAgICAgIG1pbnpvb206IGhlYWRlci5taW5ab29tLFxuICAgICAgICBtYXh6b29tOiBoZWFkZXIubWF4Wm9vbVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvbXByZXNzaW9uLFxuICBFdGFnTWlzbWF0Y2gsXG4gIEZldGNoU291cmNlLFxuICBGaWxlU291cmNlLFxuICBQTVRpbGVzLFxuICBQcm90b2NvbCxcbiAgUmVzb2x2ZWRWYWx1ZUNhY2hlLFxuICBTaGFyZWRQcm9taXNlQ2FjaGUsXG4gIFRpbGVUeXBlLFxuICBieXRlc1RvSGVhZGVyLFxuICBmaW5kVGlsZSxcbiAgZ2V0VWludDY0LFxuICBsZWFmbGV0UmFzdGVyTGF5ZXIsXG4gIHJlYWRWYXJpbnQsXG4gIHRpbGVJZFRvWnh5LFxuICB0aWxlVHlwZUV4dCxcbiAgenh5VG9UaWxlSWRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pmtiles/dist/index.js\n");

/***/ })

};
;